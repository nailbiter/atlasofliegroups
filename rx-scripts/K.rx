{M=list of n m-column vectors, delta=mxm matrix involution}
set restrict_roots(mat roots,mat delta)=
if #roots=(0,0) then  (mat:[],[]) else
let m=n_columns(delta) in 
let id=id_mat(m) in 
let M=id+delta in
let (Q,)= projection(kernel(M),null(m)) in (Q,Q*roots) fi

{throw away noncompact imaginary roots, only keep compact imaginary roots}
set discard_nci(mat roots, mat coroots, KGBElt x)=
let rd=root_datum(real_form(x)) in 
let rv_roots=[], rv_coroots=[] in 
let t=torus_factor(x) in
let theta=involution(x) in 
for alpha@i in roots do  
{ let ()=prints(t, rhocheck(rd), "alpha: ", alpha, ", ", alpha*(t+rhocheck(rd))) in}
 if ((theta*alpha != alpha) or 
      ((theta*alpha=alpha) and rattoint(alpha*(t+rhocheck(rd)))%2=0))   {SHOULD BE 4 not 2???} 
 then (rv_roots#:=alpha, rv_coroots#:=coroots[i]) fi
od;(mat:rv_roots,mat:rv_coroots)

{to embed coroots in X_*^{^delta} need to replace alpha^v with
alpha^v+^delta(\alpha_v) or 
2*(alpha^v+^delta(\alpha_v))}
set fix_coroots(mat roots,mat coroots, mat delta)=mat:
let rv=[] in 
for alpha@i in roots do 
 let checkalpha=coroots[i] in 
{  let ()=prints("alpha:", alpha, "alpha^v=", checkalpha, ", ", ^delta*checkalpha, ", ", alpha*(^delta*checkalpha), ", ", checkalpha+^delta*checkalpha) in}
  if ^delta*checkalpha=checkalpha then rv#:=checkalpha 
  elif alpha*(^delta*checkalpha)=0 then rv#:=checkalpha+^delta*checkalpha 
  elif alpha*(^delta*checkalpha)=-1 then rv#:=2*(checkalpha+^delta*checkalpha) fi od;rv

{write image of roots in L=(X_*)^{^delta} in basis of L; 
also return the matrix of (I+^delta) which takes X_* to L}
set inject_coroots(mat coroots,mat delta)=
if #coroots=(0,0) then  (mat:[],[]) else
let m=n_columns(delta) in 
let id=id_mat(m) in 
let N=id-^delta in
let (Q,)= coprojection(kernel(N),null(m)) in (Q,Q*coroots) fi

set remove_duplicates([[int]] list)=[[int]]:
if #list=0 then null(1,0) else
let rv=[[int]]:[] in
for v in list do 
 let need=true, i=0 in let()= while i<#rv do if (v=rv[i] or v=20*rv[i])  then  (need:=false, i:=#rv) else i:=i+1 fi od in 
 if need then  rv:=rv#v  fi od;rv fi

{remove roots which are 2*another root}
set remove_long([[int]] list)=[[int]]:
if #list=0 then null(1,0) else
let rv=[[int]]:[] in
for v in list do 
 let need=true, i=0 in let ()=while i<#list do if (v=2*list[i]) then (need:=false, i:=#list) else i:=i+1 fi od in
 if need then  rv:=rv#v  fi od;rv fi

{removed coroots which are (1/2)*another root}
set remove_short([[int]] list)=[[int]]:
if #list=0 then null(1,0) else
let rv=[[int]]:[] in
for v in list do 
 let need=true, i=0 in let ()=while i<#list do if (2*v=list[i]) then (need:=false, i:=#list) else i:=i+1 fi od in
 if need then  rv:=rv#v  fi od;rv fi

set K_0(RealForm G)=RealForm:
let pos_roots=positive_roots(G) in 
{let ()=prints("pos roots:", ", ", pos_roots) in}
let pos_coroots=positive_coroots(G) in 
{let ()=prints("pos coroots:", ", ", pos_coroots) in}
let delta=distinguished_involution(G),
(pos_roots,pos_coroots)=discard_nci(pos_roots,pos_coroots,KGB(G,0)) in
{let ()=prints("new pos roots:", ", ", pos_roots) in
let ()=prints("new pos coroots:", ", ", pos_coroots) in}
let (P,restricted_positive_roots)=restrict_roots(pos_roots,delta) in
let fix_positive_coroots=fix_coroots(pos_roots,pos_coroots,delta) in 
let (Q,injected_positive_coroots)=inject_coroots(fix_positive_coroots,delta) in 
{let ()=prints("restricted positive roots:", restricted_positive_roots) in}
{let ()=prints("injected positive coroots:", injected_positive_coroots) in}
let R=mat:remove_duplicates(restricted_positive_roots) in 
let S=mat:remove_duplicates(injected_positive_coroots) in 
let R_reduced=mat:remove_long(R) in 
let S_reduced=mat:remove_short(S) in 
{let ()=prints("R and S:", R, ", ", S) in }
{let ()=prints("R_reduced and S_reduced:", R_reduced, ", ", S_reduced) in }
let J=left_inverse(^P)*right_inverse(Q) in
{let ()=prints("J: ", J) in}
let JS_reduced=J*S_reduced in 
let rho=sum(R_reduced) in
let checkrho=sum(JS_reduced) in 
let simple_roots=[] in 
 let ()= for a in R_reduced do if a*checkrho=2 then simple_roots#:=a fi od in
let simple_coroots=[] in 
 let ()= for a in JS_reduced do if a*rho=2 then simple_coroots#:=a fi od in
 let rd=root_datum(simple_roots,simple_coroots,n_rows(simple_roots)) in  
 quasicompact_form(inner_class(rd, id_mat (rank(rd))))
{(mat:simple_roots,mat:simple_coroots,J,R_reduced,S_reduced,^simple_roots*simple_coroots,rd)}

set K(RealForm G)=(RealForm,int):(K_0(G), components_rank(G))