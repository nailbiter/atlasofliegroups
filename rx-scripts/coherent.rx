<modules
<translate {load translate first}
<weylgroup
{computing coherent continuation}
{-------------cayleys as sums of one or two terms----------}
{nci type I cayley as a sum of one or two terms}
set nci_Cayley(int k,Param p)=ParamPol:
let c1=Cayley(k,p) then
c2=cross(k,c1) in
if c1=c2 then null_module(real_form(p))+c1 else
null_module(real_form(p))+c1+c2 fi

{real type I cayley as a sum of one or two terms}
set r1_Cayley(int k,Param p)=ParamPol:
let c1=inv_Cayley(k,p) then
c2=cross(k,c1) in
if c1=c2 then null_module(real_form(p))+c1 else
null_module(real_form(p))+c1+c2 fi

{--------------cross action------------------------------------}

{cross action of Weyl group on parameters}
set cross(vec v,Param p)=Param:
let N=p in for k: #v downto 0  do N:=cross(v[k],N) od;N

{------------coherent continuation in basis of standards------------}

{coherent continuation action of simple root on Param in basis of standards}
set coherent_std(int k,Param p)=ParamPol:
let (x,,)=%p then
type=status(k,x) then
N=null_module(real_form(p)) in
if type=1 then N-p {compact imaginary}
elif type=3 then N+nci_Cayley(k,p)-cross(k,p) {non-compact imaginary}
else N+cross(k,p)  {complex or real} fi

{coherent continuation action of simple root on ParamPol, basis of standards}
set coherent_std(int k,ParamPol P)=ParamPol:
let N=null_module(real_form(P)) in
for (coeff,p) in %P do N:=N+coeff*coherent_std(k,p) od;N

{coherent continuation action of Weyl group on Param in basis of standards}
set coherent_std(vec v,Param p)=ParamPol:
let N=null_module(real_form(p))+p in 
for k: #v downto 0  do N:=coherent_std(v[k],N) od;N

{coherent continuation action of Weyl group on ParamPol in basis of standards}
set coherent_std(vec v,ParamPol P)=ParamPol:
let N=P in for k: #v downto 0  do N:=coherent_std(v[k],N) od;N

{------------coherent continuation in basis of irreducibles------------}

{coherent continuation of simple root on Param in basis of irreducibles}
set coherent_irr(int k,Param p)=composition_series(coherent_std(k,character_formula(p)))

{coherent continuation of Weyl group element on Param in basis of irreducibles}
set coherent_irr([int] v,Param p)=composition_series(coherent_std(v,character_formula(p)))

{coherent continuation of simple root on ParamPol, basis of irreducibles}
set coherent_irr(int k,ParamPol P)=ParamPol:composition_series(coherent_std(k,character_formula(P)))

{coherent continuation of Weyl group element on ParamPol in basis of irreducibles}
set coherent_irr([int] v,ParamPol P)=ParamPol:composition_series(coherent_std(v,character_formula(P)))

{------------coherent continuation on standards OR irreducibles ------------}

set coherent(int k,(Param,string)(p,type))=(ParamPol,string):
if (type=std) then (coherent_std(k,p),type)
elif (type=irr) then (composition_series(coherent_std(k,character_formula(p))),type)
else error("incorrect type") fi

set coherent(int k,(ParamPol,string)(P,type))=(ParamPol,string):
if (type=std) then (coherent_std(k,P),type)
elif (type=irr) then (composition_series(coherent_std(k,character_formula(P))),type)
else error("incorrect type") fi

set coherent([int] v,(Param,string)(p,type))=(ParamPol,string):
if (type=std) then (coherent_std(v,p),type)
elif (type=irr) then (composition_series(coherent_std(v,character_formula(p))),type)
else error("incorrect type") fi

set coherent([int] v,(ParamPol,string)(P,type))=(ParamPol,string):
if (type=std) then (coherent_std(v,P),type)
elif (type=irr) then (composition_series(coherent_std(v,character_formula(P))),type)
else error("incorrect type") fi

{---------------coherent families---------------------------------------}

set cf((ParamPol,string)(P,type),ratvec v)=
if is_dominant(root_datum(P),v) then translate_to((P,type),v)
else let (v_dominant,w)=make_dominant(root_datum(P),v) in 
coherent(w,translate_to((P,type),v_dominant)) fi

set cf((Param,string)(p,type),ratvec v)=cf((virtual(p),type),v)

set cf((ParamPol,string)(P,type))=(ratvec v):cf((P,type),v)
set cf((Param,string)(p,type))=(ratvec v):cf((p,type),v)


{------------phi_alpha: translation of stds/irrs away from one  wall-----------}

set phi((Param,string)(p,type), int k, ratvec v)=(ParamPol,string):
let (gamma,rd)=(infinitesimal_character(p),root_datum(p)) then a=simple_coroots(rd)[k] in
 if not(is_integer(v-gamma)) then error("translation is not integral") 
 elif not is_regular(rd,v) then error("translation is not to regular infinitesimal character") 
 elif not ((a*gamma)=0 and (a*v !=0)) then error("this is not translation away from a single root wall") 
 elif (#singular_roots(rd,gamma) !=1) then error("this is not translation away from a single root wall") fi;\
 (translate_to(p,v),type)+coherent(k,(translate_to(p,v),type))

{------------phi_alpha: translation of ParamPol away from one  wall-----------}

set phi((ParamPol,string)(P,type),int k,ratvec v)=(ParamPol,string):
let Q=(null_module(P),type) in for (w,q) in %P do Q +:= w*phi((q,type),k,v) od; Q

{set psi(ParamPol P,int k)= ParamPol:let Q=null_module(P) in for (w,q) in %P do Q +:= (w,psi(q,k)) od; Q}


{------------phi_alpha*psi_alpha: translation of stds/irrs to and from from one  wall-----------}

set phi_psi((Param,string)(p,type),int k)=phi(psi((p,type),k),k,infinitesimal_character(p))
