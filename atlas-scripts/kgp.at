<sort.at
<Weylgroup.at {for make_dominant}

{also see parabolics.at}

{
see "K_types in atlas", in dropbox, ultimately on atlas web site

Fix a subset S of the simple roots, defining the complex standard
parabolic P_S (see parabolic.at) of type S. We define a set KGP(S) (a
quotient of KGB) such that (roughly) KGP(S) <-> K\G/P_S

More precisely for any x\in KGB and p(\xi)=x then
KGP(S) is canonically in bijection with K_\xi\G/P_S, i.e.
K_\xi conjugacy classes of parabolics of type S.

K orbits on G/P_S, equivalently K-conjugacy classes of parabolics of type S
Given a RealForm and a subset S of the simple roots
S -> partial order on KGB, generated by ascents not in S
  -> equivalence relation generated by this
KGB/equivalence <-> K\G/P_S
Define KGP to be KGB modulo this equivalence

Data: ([int],KGBElt)=(S,x) where S is a subset of the simple roots of root_datum(x)
Equivalence: (S,x)=(S',y) if these correspond to the same K orbit on G/P_S, which means:
 real_form(x)=real_form(y), S=S'  (i.e. same complex parabolic), and
 x=y in the equivalence defined by S
In particular, given (S,x), taking x itself for the strong real form,
(S,x) goes to K_x-conjugacy class of the standard parabolic P_S

Given (S,x),
write [x_1,...,x_n] for the S-equivalence class of x\subset KGB

The last element x_n is maximal, and is uniquely determined
This orbit of K on G/P_S is closed <=>x_1 is closed in KGB
}

{data type for a K-orbit on G/P_S, equivalently
a K-conjugacy class of parabolics of type S
([int] S,KGBElt x)
S is a subset of the simple roots
(S,x)=(S,y) if x is S-equivalent to y, see below
Associated to (S,x) is a canonical K-conjugacy class of parabolics of type S
More precisely, for each \xi, a K_\xi-conjugacy class of parabolics of type S
}
:KGPElt=([int], KGBElt)
:Parabolic=([int], KGBElt)  {synonym}

{some auxiliary routines needed for defining equivalence of data}
set number(KGBElt x)=let (,n)=%x in n
set sort_by((KGBElt -> int) f)= ([KGBElt] v) [KGBElt]:
  for index in inv_standardisation(for x in v do f(x) od) do v[index] od
set sort=([KGBElt] -> [KGBElt]):sort_by((KGBElt x) int: number(x))

set min([KGBElt] y)=sort(y)[0]
set max([KGBElt] y)=sort(y)[#sort(y)-1]

set S(KGPElt y)=[int]:let (S,)=y in S
set root_datum(KGPElt y)=let (,x)=y in root_datum(x)
set real_form(KGPElt y)=let (,x)=y in real_form(x)

{complement of subset of simple roots in rank n}
set complement(int n,[int] S)=[int]:
let rv=for i:n do i od in for j in reverse_sort(S) do  rv:=delete(rv,j) od;rv

{add i to list if (and only if) it is new}
set add_new(int i,[int] list)=[int]: if find(list,i)=-1 then list#i else list fi

{elements above x one step in the partial order given by ascents in S}
set up_neighbors([int] S,KGBElt x)=[int]:
let rv=[int]:[] in
for i in S do
 let t=status(i,x) in
  if t=3 then rv#:=number(Cayley(i,x))
  elif t=4 then rv#:=number(cross(i,x)) fi od;sort_u(rv)

{elements below x one step in the partial order}
set down_neighbors([int] S,KGBElt x)=[int]:
let rv=[int]:[] in
for i in S do
 let t=status(i,x) in
  if t=2 then
   let y=Cayley(i,x) in
    rv#:=number(y); rv#:=number(cross(i,y))
  elif t=0 then rv#:=number(cross(i,x)) fi od;sort_u(rv)

set is_maximal_in_partial_order([int] S,KGBElt x)=bool:#up_neighbors(S,x)=0

{maximal elements in the partial order}
set maximal_in_partial_order(RealForm G,[int] S)=[KGBElt]:
let rv=[int]:[] in for x in KGB(G) do if is_maximal_in_partial_order(S,x) then rv#:=number(x) fi od;
for i in sort(rv) do KGB(G,i) od

{(unique) maximal element in equivalence class of x}
set maximal([int] S,KGBElt x)=KGBElt:
let rec_fun f([int] S,KGBElt x)=KGBElt:
if is_maximal_in_partial_order(S,x) then x else f(S,KGB(real_form(x),up_neighbors(S,x)[0])) fi in f(S,x)

set canonical_representative(KGPElt y)=(S(y),maximal(y))
set x(KGPElt y)=KGBElt:maximal(y)

{equivalence class of KGB element in partial order defined by S}
set equivalence_class_of(KGPElt y)=[KGBElt]:
let (S,x)=y then
x_max=maximal(S,x) in
let G=real_form(x_max),rv=[number(x_max)], to_do=[number(x_max)] in
while #to_do>0 do
 let y=KGB(G,to_do[0]) then
 new=down_neighbors(S,y) in
 for i in new do rv:=add_new(i,rv);to_do:=add_new(i,to_do) od;
 to_do:=delete(to_do,0) od;for i in sort(rv) do KGB(G,i) od

{minimal element from equivalence class (unlike x_max, not unique)}
set x_min(KGPElt P)=min(equivalence_class_of(P))

{set of KGP elements (P,S), S=[KGBElt] is an equivalence class
KGP(G,P) is in bijection with K\G/P}
set KGP(RealForm G,[int] P)=[KGPElt]:
for x in maximal_in_partial_order(G,P) do (P,x) od

{sometimes convenient to just keep the numbers, although this loses the information of what G is}
set KGP_numbers(RealForm G,[int] S) =[int]:for (,x) in KGP(G,S) do number(x) od



{test y in K\G/P_S is closed: <=> length(first element)=0}
set is_closed(KGPElt y)=bool:let eq=equivalence_class_of(y) in length(min(eq))=0

set KGP_elt([int] P,KGBElt x)=KGPElt:(P,x)

{parabolic determined by lambda q(lambda)=l(lambda)+u(lambda)}
set KGP_elt(ratvec lambda,KGBElt x)=KGPElt:
let rd=root_datum(x) then
{()=prints("lambda=",lambda) then}
P=[int]:[]  then
(lambda_dom,w)=make_dominant(rd,lambda) then
{()=prints("w=",w) then}
y=cross(inverse(w),x) in
for a@i in simple_roots(rd) do if a*lambda_dom=0 then P#:=i fi od;
KGP_elt(P,y)

set parabolic([int] P,KGBElt x)=Parabolic:KGP_elt(P,x)  {simple roots P}
set parabolic(ratvec lambda,KGBElt x)=Parabolic:KGP_elt(lambda,x) {lambda in \h^*}

{test y in K\G/P_S is open: <=> last element of y is last element of KGB}
set is_open(KGPElt y)=bool:let eq=equivalence_class_of(y) then
G=real_form(y) in  maximal(y)=KGB(G,KGB_size(G)-1)

{(S,x)=(T,y) if these give the same K-orbit of parabolics}
set =(KGPElt (S,x),KGPElt (T,y))=bool: real_form(x)=real_form(y) and S=T and maximal(S,x)=maximal(S,y)





