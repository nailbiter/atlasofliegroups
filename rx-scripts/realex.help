Brief introduction to 'realex', the new interface to the Atlas software
'realex' stands for Rewritten Expression-based  Atlas of Lie groups EXecutable


1 Introduction

The program 'realex', built from the files in this directory and from a large
part of the source files of the 'atlas' program, provides access to its
functions in an expression-oriented fashion. Whereas 'atlas' will enter a
dialogue whenever it needs some parameter to be set (inner class, real form,
Cartan class,...) these parameters can be defined by expressions in 'realex'.
As a consequence such parameters can be more flexibly handled, results of
computations can be reused, and scripting and programming become possible.

To compile realex, you need the latest release of the 'cwebx' system, unless
the output files produced by 'cwebx' were already included in your copy of the
atlas sources; check the presence in atlas/sources/interpreter of the files
{buffer,built-in-types,evaluator,lexer,main,parsetree,types} with extensions
.cpp and (except for main) .h to see if this is the case. If these files do
not exist, get 'cwebx' by clicking on the indicated link at

http://www-math.univ-poitiers.fr/~maavl/CWEBx/

unpack in some directory, type make, then make sure that the resulting
programs 'ctanglex' and 'cweavex' are in your $PATH (possibly by making
symbolic links to them from your ~/bin directory, if you use one), and that
the macro file cwebxmac.tex is in some place where TeX will find it (check
your $TEXINPUTS environment variable; a quick solution is to copy the file to
this atlas/sources/interpreter directory). Once these tools are in place, the
'make' facility will automatically invoke them to create all the files
mentioned above when they are needed.

Apart from that, you need tools like (GNU) 'make', 'bison', and a compiler
like 'g++' which you already need to compile the atlas program (but contrary
to atlas, you need at least version 4.0 of gcc/g++ to compile realex, since
realex uses the TR1 library extension whose support was introduced in their
version 4.0). Once you are set, type 'make' in the atlas/sources/interpreter
directory (or 'make realex' in the atlas directory) to build realex. Again you
can install a symbolic link from somewhere in your $PATH to
atlas/sources/interpreter/realex to ensure that it will be executed by the
command 'realex'. If atlas was compiled before you build realex, the latter
compilation will use the existing object files; if not it will do the
necessary compilations itself (this involves nearly all atlas modules, but not
all), and take quite a bit longer.


2 Comparison with atlas

Consider for instance the following session

  $ atlas
  This is the Atlas of Reductive Lie Groups Software Package version...
  Enter "help" if you need assistance.

  empty: blocksizes
  Lie type: B5.A3.T1
  elements of finite order in the center of the simply connected group:
  Z/2.Z/4.Q/Z
  enter kernel generators, one per line
  (ad for adjoint, ? to abort):
  1/2,0/4,0/4
  0/2,2/4,2/4

  enter inner class(es): scc
	0      0      0      0      0      0      0      1
	0      0      0      0      0      0      0     11
	0      0      0      0      0      0      0     10
	0      0      0      0      0      0      0     75
	0      0      0      0      0      0      0    110
	0      0      0      0      0      0      3     21
	0      0      0      0      0      0      0    305
	0      0      0      0      0      0      0    750
	0      0      0      0      0      0     33    231
	0      0      0      0      0      0      0    810
	0      0      0      0      0      0      0   3050
	0      0      0      0      0      0    225   1575
	0      0      0      1     25    130      0   1342
	0      0      0      0      0      0      0   8100
	0      0      0      0      0      0    915   6405
	0      0      0     10    250   1300      0  13420
	0      0      0      0      0      0   2430  17010
	3     75    390     21    525   2730   4026  28182
  main: qq
  $

Using realex, the same result can be obtained as follows

  $ realex
  Enter expressions:
  expr> set ic=inner_class("B5.A3.T1",[[1,0,0]/2,[0,1,1]/2],"scc")
  Identifier ic: InnerClass
  expr> ic
  Value: Complex reductive group of type B5.A3.T1, with involution defining
  inner class of type 'ccc', with 18 real forms and 8 dual real forms
  expr> block_sizes(ic)
  Value:
  | 0,  0,   0,  0,   0,    0,    0,     1 |
  | 0,  0,   0,  0,   0,    0,    0,    11 |
  | 0,  0,   0,  0,   0,    0,    0,    10 |
  | 0,  0,   0,  0,   0,    0,    0,    75 |
  | 0,  0,   0,  0,   0,    0,    0,   110 |
  | 0,  0,   0,  0,   0,    0,    3,    21 |
  | 0,  0,   0,  0,   0,    0,    0,   305 |
  | 0,  0,   0,  0,   0,    0,    0,   750 |
  | 0,  0,   0,  0,   0,    0,   33,   231 |
  | 0,  0,   0,  0,   0,    0,    0,   810 |
  | 0,  0,   0,  0,   0,    0,    0,  3050 |
  | 0,  0,   0,  0,   0,    0,  225,  1575 |
  | 0,  0,   0,  1,  25,  130,    0,  1342 |
  | 0,  0,   0,  0,   0,    0,    0,  8100 |
  | 0,  0,   0,  0,   0,    0,  915,  6405 |
  | 0,  0,   0, 10, 250, 1300,    0, 13420 |
  | 0,  0,   0,  0,   0,    0, 2430, 17010 |
  | 3, 75, 390, 21, 525, 2730, 4026, 28182 |

  expr> quit
  Bye.
  $

The 'inner_class' function does essentially the same as the dialogue from the
line 'Lie type:' up to and including the one with 'enter inner class(es):' in
the atlas. Note however that the specification [[1,0,0]/2,[0,1,1]/2], of the
kernel generators is somewhat more liberal than allowed in the atlas program.
For root data that are simply connected or adjoint, so that they don't need
explicit mention of kernel generators, there are functions available to build
them directly, and to introduce corresponding inner classes.

So one difference is that rather than being asked to specify a complex group
and an in inner class after calling the blocksizes command, one needs to
construct an inner class value first, and then invoke the block_sizes function
with the inner class as argument. In the realex session above the variable
'ic' was set to the computed inner class; the reply confirms (only) its type
InnerClass. Typing 'ic' after this produces a more elaborate description of
the inner class, reporting the Lie type, inner class type (note that the 's'
for the factor 'B5' was converted to 'c') and numbers of (dual) real forms.
Then the variable 'ic' was used as argument to block_sizes, and it could
subsequently be used in other function calls as well. Alternatively one could
have called directly:

  block_sizes(inner_class("B5.A3.T1",[[1,0,0]/2,[0,1,1]/2],"scc"))

but then of course the inner class would not have been available afterwards in
the variable 'ic'. The matrix resulting from the call was printed, but it
could instead have been assigned to a variable as well. One can define any
number of variables, with values of any of the types available. This provides
more flexibility of use than the atlas interface, which can basically remember
just one inner class and one real form between different commands. In addition
the realex program provides programming constructions, and allows you to
define scripts and functions for later use.

The set of primitive functions provided is described in the file
'functions.help' in this directory, and in the subdirectory rx-scripts of the
atlas root directory there is a script 'basic.rx' with user-defined functions
that complement the primitive ones. You can load by typing at the realex prompt

expr> <basic

provided you started realex in the rx-scritps directory; if not you need to
specify a complete path (absolute or relative from where you started realex)
so that realex can find the basic.rx script. If the file is found, realex
responds by printing the types of all values defined in this script.

In this file we shall document other aspects of the realex program.


3 Design principles and current limitations

The realex interpreter is expression based, which means that the text entered
serves most often to designate values to be computed rather than actions to be
performed. Its design is close to that of functional programming languages,
but it does provide assignable variables and loops. (In fact, strict scoping
rules (derived from the lambda-calculus) make it somewhat difficult to define
functions recursively (a function must be defined before it is named, so its
definition cannot refer to its name) which is unusual for a functional
programming language; recursion can however be achieved using assignment.)

It is important to realize the distinction between creating names and
assigning to them. The interpreter will refuse expressions with unknown names
in them, whether they are being used or assigned to (realex is not a symbolic
algebra language, which would take unknown names to stand for indeterminates).
Names are introduced using the keyword 'set' (for permanant names) or using
the keyword 'let' (for local names, whose scope is limited to the current
expression, or even to part of it). Once a name is introduced, its value can
be altered by assignment, which is written ':=' (in the tradition of Algol and
Pascal, not Fortran and C); such an assignment should not alter the type
associated to the name. Assignment is used almost exclusively for programming
purposes; for "ordinary" use of realex, one rarely needs ':='. Both 'set' and
'let' follow the name(s) being introduced by '=' (not ':='); apart from that,
'=' also serves as equality testing operator (for certain types).

The language is strictly typed, so that type-correctness of expressions must
be established before their evaluation is attempted. This means that most
common errors are caught before execution starts, and error messages can be
more meaningful by referrring to the offending expression rather than to its
value. Nonetheless, type checking is a complicated process, which could
occasionally produce cryptic error mesages. Most of the time the system can
figure out the types from the expressions, so the user need not write them
explicitly; however the types of arguments of user-defined functions must
always be specified. Types are also used to allow overloading, which means
that it is possible to give the same (natural) function or operator name to
different operations; in each expression using these names, the type system
then determines which instance is to be used. This applies in particular to
user function definitions, so that binding of overloaded operators and
functions is done statically (when the user defines the function rather than
when it gets executed). Currently types are straightforward and therefore
somewhat limited; this is quite sufficient for using the atlas functionality,
though for advanced programming the set of possible types might need to be
enlarged in the future.

The primitive data types currently available for values do not yet cover all
those that the atlas library can handle, and for the types available (root
data, inner classes, real forms, Cartan classes, KGB elements, parameters for
(standard) modules and formal sums of those) not all reasonable functionality
is implemented (for instance equality tests are sometimes missing). Some data
types used internally (such as Weyl groups, polynomials) may appear in printed
output but cannot be further manipulated. The programming language itself is
fairly complete, with constructions like variables, loops and conditionals, as
well as functions and operators (both built-in and user-defined), but
certainly still leaves a large number of things to be improved.


4 Types

The realex interpreter is strongly and statically typed: it first analyses the
expressions and definitions given by the user to verify that types can be
attributed to all subexpressions, and all operations are defined for the types
they are applied to; only if the expression passes this test does the system
attempt to evaluate the expression. Thus many computations that would produce
problems on execution are signalled. For instance realex complains about

  expr> block_sizes (GL(5))
    Type error:
      Subexpression GL(5) has wrong type: found RootDatum while InnerClass was
      needed.
    Type check failed

because the built-in function 'block_sizes' requires an 'InnerClass' value but
'GL' produces a value of type 'RootDatum'. In the following example

  expr> Lie_type(Cartan_matrix(GL(5)))
  Error during analysis of expression Lie_type(Cartan_matrix(GL(5)))
    Failed to match `Lie_type' with argument type mat
  Type check failed

the message is somewhat different, because the name `Lie_type' corresponds to
several functions, and realex can only report that none of them applies for
the given expression. To find out which instances are known, one can enter:

  expr> whattype Lie_type ?
  Overloaded instances of Lie_type
    string->LieType
    RootDatum->LieType

showing that either a string or a RootDatum value would have worked instead of
a (Cartan) matrix. For instance

  expr> Lie_type(GL(5))
  Value: Lie type 'A4.T1'
  expr> Lie_type("E6.T1.D4")
  Value: Lie type 'E6.T1.D4'

All built-in operators and functions are defined as "overloaded" symbols, even
if only one meaning is built-in, as is the case for 'block_sizes'. This allows
the user to add new definitions of those symbols without overriding those
built in. On the, the values of all identifiers that are not functions are
stored in a different table, which allows only one value to be associated at
any time to a given identifier.

The interpreter knows about several "primitive" types, which it distinguishes
but for which (in contrast to "composite" types discussed below) it usually
does not provide specific language constructions (although it does know for
instance that a Boolean value can be tested in a conditional expression).
These basic types are:

type		represents
-----------------------------------
bool		truth values
int		machine integers (32 or 64 bits depending on the machine)
rat		rational numbers (quotient of two machine integers)
string		string of characters
vec		vector of machine integers
mat		matrix of machine integers
ratvec          rational vector (vector numerator with common denominator)
LieType		Lie type (such as D4.A2.T1.E8)
RootDatum	root datum, specifying a connected Complex reductive group
InnerClass      inner class of real forms (based root datum with involution)
RealForm	real form within an inner class
DualRealForm    dual real form within an inner class
CartanClass     class of Cartan subgroups within an inner class
Split		"split integer" a + b.s where s^2=1
Param		a standard module, or maybe an irreducible module
ParamPol	virtual module with signature (Param values with Split coefs)

Constant values of type bool, int and string can be typed as usual (use 'true'
or 'false' (without quotes) for truth values, and a string in double-quotes
(with any contained double-quote characters doubled) for strings. Strings
cannot contain newline characters. Values of other basic types can only be
obtained by using appropriate operators and functions (for instance 22/7 has
type 'rat' and GL(5) has type 'RootDatum'), or sometimes via implicit
conversions (see below).

Composite types are either array (list) types, tuple types or function types.
Array and tuple types both construct aggregates by combining a sequence of
component values; for array types all components must have the same type and
there could be any number of them (including none at all), while for tuple
types the type explicitly enumerates the types of the components, so in
particular the number of components is determined by the type. A function type
specifies zero or more argument and result types; for either, unless exactly
one such type is specified the argument or result type is actually a tuple
type. Thus if t0,t1,t2,t3 are types, one has composite types like:

[t0]		array of elements all of which have type t0
[[t0]]		array of elements all of which have type [t0] (a list of lists)
...		etc
(t0,t1)		2-tuple formed of components of types t0 and t1 respectively
(t0,t1,t2)	3-tuple, with components of types t0,t1,t2 respectively
(t0,t1,t2,t3)	4-tuple, with components of types t0,t1,t2,t3 respectively
...		etc
void		0-tuple (irrelevant value)
(t0->t1)	function with argument of type t0 and result of type t1
(t0,t1->t2)	function with argument of type (t0,t1) and result of type t2
(t0->t1,t2)	function with argument of type t0 and result of type (t1,t2)
(t0,t1->t2,t3)	function with argument of type (t0,t1), result of type (t2,t3)
(t0,t1->)	function with argument of type (t0,t1) and no useful result
...		etc

Often the user does not have to write any types, and the system will take care
of deriving primitive and composite types as implicitly specified by the
expression. However when writing user defined functions, the types of the
arguments must be specified, so that types can be checked for the function
body; once this check succeeds, a type is attributed to the function, and it
will henceforth be treated just like a built-in function of that type would be
(and one can in fact for instance form an array that contains both built-in
and user-defined functions, provided they all have the same (function) type).

Array values can be constructed by enclosing a comma-separated lists of
component expressions (all of the same type) in brackets, as in [1,-4,3*6],
which is called a row display. If 'v' is an identifier holding an array value,
its individual components can be accessed by subscripting, as in 'v[i]' (in
fact 'v' could be replaced here by any row-valued expression, although
computing such a value just to retain one of its component seems wasteful).

If instead of brackets of a row display one uses parentheses to enclose a
sequence of expressions, then a tuple rather than an array is formed (except
if there is exactly one expression in the sequence: then parentheses just
imply grouping as used for instance to override operator precedence). Such a
"tuple display" can be used as a function argument without additional
parentheses, so for instance 'f(x,y)' applies the function 'f' to a 2-tuple
with components 'x' and 'y'. But one is not obliged to write a tuple display
for function arguments; for instance after 'set z=(3,4)' the variable 'z'
holds a 2-tuple, and (the same instance of) 'f' may also be called as 'f(z)'.
One could even for instance multiply the components of 'z' by writing '*z';
indeed the expression '3*4' is transformed by the parser into '*(3,4)', and
(currently) this form is also used in error messages, for instance in

  expr> GL(10/2)
  Type error:
    Subexpression /(10,2) has wrong type: found rat while int was needed.
  Type check failed

(The operator '/' on integers produces a rational number; for integer division
ignoring the remainder one should write 10\2 instead).

To decompose tuples, a simple form of pattern matching is provided: wherever
an identifier can be introduced, one may also specify a tuple of identifiers,
if the type of the value is appropriate, and the components will be bound to
the corresponding identifiers. So whereas

  expr> set x=E

introduces the identifier 'x' whose value (and type) are set to that of the
expression 'E', one can alternatively say

  expr> set (x,y)=E

provided that E produces a pair (some value of some 2-tuple type), and the
variable 'x' will be set to the first component of the pair, and 'y' to the
second component. In either case, the types of the variables introduced will
be reported, as in

  expr> set (q,r) = 22 \% 7   { Euclidean division with remainder }
  Identifiers q: int, r: int
  expr> q    { quotient }
  Value: 3
  expr> r    { remainder }
  Value: 1

The same pattern-matching is also allowed when introducing parameters of
user-defined functions, or when introducing local variables; the latter uses a
syntax like that of 'set' used above,, but with 'let' instead of 'set', and
followed by 'in' and the "body" if the let-expression, the expression where
the local variable is in scope. So to interchange the components of 'z', say

  let (x,y)=z in (y,x)

If only the first component is needed, there is no need to give a name to the
other one, so one can write

  let (x,)=z in x

Local variables get their value and type from the expression between '=' and
'in', and are independent of any meaning that might previously be associated
to the identifier; after evaluation of the body, the local identifiers
introduced, and their values associated to them, are forgotten. (Forgetting
does not apply if a function object that may still be in existence made a
reference to the identifier; such a function will continue to work properly).

Using a local variable, the initial example could have been given in a form
that does not permanently bind the identifier 'ic':

  expr> let ic = inner_class("B5.A3.T1",[[1/2,0,0],[0,1/2,1/2]],"scc")
  L > in block_sizes(ic)
  Value:
  | 0,  0,   0,  0,   0,    0,    0,     1 |
  ...

Note that realex recognised that the let-expression was incomplete after the
first line, and changed the prompt in the second line to indicate this.


5 Implicit conversions

When types do not match exactly, realex will sometimes insert implicit type
conversions that are accompanied by conversions of the corresponding values.
For instance, although the 'vec' type, which function of the atlas library
use, models the same values as '[int]' (pronounced "row of int"), the two
types have different internal representations (that of 'vec' is more compact),
and a row display will only produce '[int]'. What makes it nevertheless
possible to provide 'vec' values to functions that need it is the fact that
realex will convert between 'vec' and '[int]' in contexts that require this.

Here is a list of all implicit type conversions

  vec       <-> [int]
  mat       <-> [vec]    (vectors are columns of the matrix)
  mat       <-> [[int]]  (inner arrays are columns of the matrix)
  int        -> rat      (denominator 1)
  ratvec    <-> [rat]    (ratvec has least common denominator)
  ratvec     -> vec
  [int]      -> ratvec
  int	     -> Split
  string     -> LieType  (applies Lie_type function)
  InnerClass -> RootDatum
  RealForm   -> InnerClass
  RealForm   -> RootDatum
  Param	     -> ParamPol (parameter is converted to final parameter(s) first)

The one-directional conversions int->rat and string->LieType are mainly a
convenience to users, as these conversion could be written out explicitly:

  expr> 3+1/7       { same as 3/1+1/7 }
  Value: 22/7
  expr> Cartan_matrix("E8")  { same as Cartan_matrix(LieType("E8")) }
  Value:
  |  2,  0, -1,  0,  0,  0,  0,  0 |
  |  0,  2,  0, -1,  0,  0,  0,  0 |
  | -1,  0,  2, -1,  0,  0,  0,  0 |
  |  0, -1, -1,  2, -1,  0,  0,  0 |
  |  0,  0,  0, -1,  2, -1,  0,  0 |
  |  0,  0,  0,  0, -1,  2, -1,  0 |
  |  0,  0,  0,  0,  0, -1,  2, -1 |
  |  0,  0,  0,  0,  0,  0, -1,  2 |

If desired, a context requiring a given type can be created by giving the type
name followed by a colon. So while one gets an error for

  expr> [1,1/2,1/3,1/4]
  Type error:
    Subexpression /(1,2) has wrong type: found rat while int was needed.
  Type check failed

this can be repaired by asking for a list of 'rat'

  expr> [rat]: [1,1/2,1/3,1/4]
  Value: [1/1,1/2,1/3,1/4]

Alternatively this input could be turned into a 'ratvec'

  expr> ratvec: [1,1/2,1/3,1/4]
  Value: [ 12,  6,  4,  3 ]/12

This conversion is applied whenever a list of rationals (or integers) is given
in place of a 'ratvec'; for instance inner_class takes a list of 'ratvec'
values as second "kernel generators" argument, but they can be specified as

  expr> inner_class ("D4.A3",[[0,1/2,1/4],[0,0,1/2]],"ss")
  Value: Complex reductive group of type D4.A3, with involution defining
  inner class of type 'cs', with 10 real forms and 15 dual real forms

There could be one kernel generator, say [[0,1/2,1/4]], or none at all [];
however just [0,1/2,1/4] is not accepted since a list of vectors is required,
and realex will not turn a value into a singleton list automatically.

Matrices can be built from lists of lists of integers by requiring 'mat':

  expr> mat: [[1,2],[3,4,5]]
  Value:
  | 1, 3 |
  | 2, 4 |
  | 0, 5 |

In place of each list of integers one can also use a vector-valued expression
(for instance an identifier bound to a vector value); these become columns of
the matrix. For specifying a matrix by rows, a special syntax is provided:

  expr> [ 1,2 | 3,5,4 | 7 ]
  Value:
  | 1, 2, 0 |
  | 3, 5, 4 |
  | 7, 0, 0 |

Note that 'mat:' is not required here, the syntax itself forces a matrix
result. On the other hand it will not accept 'vec' values as lines; to
construct a matrix from its row vectors do ^[r_0,r_1,...], where the caret
is a prefix operator indicating transposition.

For most implicit conversions the opposite conversion is also available, so to
decompose a matrix M into the list of its column vectors, just write

  expr> [vec]: M

For values of the types RootDatum, ..., CartanClass, it is not practical to
print a complete description of the value stored, so upon returning such
values, only a summary of their properties is printed (for instance:
"simply connected adjoint root datum of Lie type 'A6.T1'"). In many cases
functions exists that allow more detailed information to be extracted from
these values.

6 Defining and modifying identifiers

As shown in the examples above, global identifiers are introduced using 'set',
while local identifiers are introduced with 'let'. Local identifiers can be
used only in the expression after the following 'in', which may however be an
arbirarily large composite expression or clause. Note that in both cases
the initial keyword is necessary; without it the '=' would be interpreted as
equality test (probably leading to an error due to an undefined left operand).

For modifying an existing variable, global or local, the assignment operator
':=' is provided. It is mainly intended for programming use rather than for
expression evaluation. For instance, a function computing the first n natural
numbers 0,...,n-1 may be written as follows (while-loops are explained later)

  expr> set first(int n) = let i=0 in while i<n do i next i:=i+1 od
  Defined first: (int->[int])

Here the part 'let i=0 in' serves to introduce 'i' as a variable, whose value
is then repeatedly modified by the assignment 'i:=i+1'. (The values from
successive iterations of the loop body are then gathered into a row-of-int
value; a property of realex that is uncommon in other languages.) Any
identifier can be used as a variable, including one introduced as a function
argument; for instance for a decreasing list of the same values one could write

  expr> set first_downwards(int n) = while (n:=n-1)>=0 do n od
  Defined first_downwards: (int->[int])

For identifiers holding a list, vector or matrix, one can also assign to
individual entries, as in 'v[i]:=x' or 'm[i,j]=0'. Such assignments ae
implemented in such a way that there is never any effect of sharing (parts of)
composite values between different identifiers; for instance after 'let v=w in
v[i]:=x; v', the value of 'w' remains unmodified. By the same token, a
function that assigns to the names of its arguments, whether they are simple
or composite values, will never thereby modify the actual arguments in the
caller. For instance the assignment to its argument in the above function
'first_downwards' does not have any affect for callers of this function, who
do not know about the identifier 'n' in 'first_downwards', or of its use.

If the purpose of a function is to modify an argument value, the modified
value must be passed back as a result and the caller can do with it as she
likes. On the other hand the body of a (possibly local) function may assign
to any identifiers valid (in scope) at its point of definition, including
those introduced outside of the function itself. The basic and general rule is
that an assignment only affects the identifier that it explicitly names.

As a convenience one can write 'x +:= y' instead of 'x := x + y', and
similarly for any operator in the place of '+', so in the above examples one
could say i+:=1 and n-:=1. This is a transformation performed in the parser,
so '+:=' is not really an operator (and is composed of separate '+' and ':=').
It should be noted that this requires a simple variable as left operand: the
parser will reject for instance v[i]+:=1; this should be written v[i]:=v[i]+1.

The rules for assignment are quite different from the introduction of a
variable: the variable must have been introduced beforehand, and the value
assigned must have the same type as the previously held value. An assignment
need not be used exclusively for the change to its variable it causes; it is
also a subexpression in its own right (as is used in the definition of
'first_downwards'), and as such it represents the value that was assigned.

7 Defining functions

One can also define functions. The normal way to do so is using a variation of
the 'set ' syntax (which has no counterpart for 'let'), as in

  expr> set f (LieType lt)=
  = > let rd = simply_connected_datum (lt)
  L > then ic = inner_class(rd,"s")
  L > then rf = quasisplit_form (ic) , drf = dual_quasisplit_form (ic)
  L > in print_block(rf,drf)
  Defined f: (LieType->)
  expr> f("A2")
  entering block construction... K\G/B and dual generated... done
  0(0,5):  0  0  [C+,C+]  2  1   (*,*)  (*,*)   e
  1(1,4):  1  0  [i2,C-]  1  0   (3,4)  (*,*)   2,1
  2(2,3):  1  0  [C-,i2]  0  2   (*,*)  (3,5)   1,2
  3(3,0):  2  1  [r2,r2]  4  5   (1,*)  (2,*)   1,2,1
  4(3,1):  2  1  [r2,rn]  3  4   (1,*)  (*,*)   1,2,1
  5(3,2):  2  1  [rn,r2]  5  3   (*,*)  (2,*)   1,2,1
  expr> f("G2")
  entering block construction... K\G/B and dual generated... done
   0(0,9):  0  0  [i1,i1]   1   2   ( 3, *)  ( 4, *)   e
   1(1,9):  0  0  [i1,ic]   0   1   ( 3, *)  ( *, *)   e
   2(2,9):  0  0  [ic,i1]   2   0   ( *, *)  ( 4, *)   e
   3(3,8):  1  1  [r1,C+]   3   6   ( 0, 1)  ( *, *)   1
   4(4,7):  1  2  [C+,r1]   5   4   ( *, *)  ( 0, 2)   2
   5(5,6):  2  2  [C-,C+]   4   8   ( *, *)  ( *, *)   1,2,1
   6(6,5):  2  1  [C+,C-]   7   3   ( *, *)  ( *, *)   2,1,2
   7(7,4):  3  1  [C-,i2]   6   7   ( *, *)  ( 9,11)   1,2,1,2,1
   8(8,3):  3  2  [i2,C-]   8   5   ( 9,10)  ( *, *)   2,1,2,1,2
   9(9,0):  4  3  [r2,r2]  10  11   ( 8, *)  ( 7, *)   2,1,2,1,2,1
  10(9,1):  4  3  [r2,rn]   9  10   ( 8, *)  ( *, *)   2,1,2,1,2,1
  11(9,2):  4  3  [rn,r2]  11   9   ( *, *)  ( 7, *)   2,1,2,1,2,1

The syntax for defining functions is: after 'set' and the function name first
a parameter list, formed of pairs of the form '<type> <identifier>' separated
by commas and enclosed in parentheses, then a colon (optionally preceded by a
return type), then '=', and then the expression giving the function body. In
the example the function body is a 'let' construction introducing first the
local variable 'rd', then (preceded by 'then', which here is equivalent to 'in
let') 'ic', and finally (after another 'then') 'rf' and 'drf' (in parallel,
separated by a comma) and finally calling (after 'in') the function
'print_block'. The latter returns no value, whence the function 'f' does not
either, and gets type (LieType->). Note that after calling the function 'f'
the 'Value' indication before the output is suppressed (the printed output is
not a (composite) value, and is not accessible for further manipulation).

Functions defined by this syntax are stored in a different table than
variables introduced by 'set xxx = ...', which means they can coexist with a
value of the same name; more importantly this other table can store multiple
definitions for the same function name, whence it is called the overload
table. So after the above definition one could continue with

  expr> set f(int n)=n+1
  Added definition [2] of f: (int->int)
  expr> [f(4),f(f(6))]
  Value: [5,8]
  expr> f("A1")
  entering block construction... K\G/B and dual generated... done
  0(0,1):  0  0  [i1]  1   (2,*)   e
  1(1,1):  0  0  [i1]  0   (2,*)   e
  2(2,0):  1  1  [r1]  2   (0,1)   1

Note how the response after the second 'set f' mentions the addition of a
definition and the total number [2] of definitions for 'f' now known. When
encountering a call of 'f', realex finds out which definition to apply based
on the type of the argument (list). All functions (and operators) built into
realex are defined in the overload table, often with more than one initial
definition for a function name. The user can add definitions to names that
also refer to built-in functions, they will be overloaded together with the
original definitions. If the following instances of 'inner_class' had not
already been built into realex, the user could have defined them as follows:

  set inner_class (LieType lt,[ratvec] gen,string ict) =
  let basis = quotient_basis(lt,gen)
  then rd   = root_datum(lt,basis)
  then inv  = involution(lt, basis, ict)
  in inner_class(rd,inv)

  set inner_class (RootDatum rd, string ict)=
  let lt = type (rd), basis=transpose_mat(coroot_radical(rd))
  in inner_class(rd, involution(lt, basis, ict))

to add two new meanings to the inner_class function. The fact that these
definitions themselves use (in the final line) a more basic version of
inner_class is OK, because they can be distinguished by the argument types.

Since the two definitions above are essentially the same as the ones built in,
it is in fact legal to give them: by a special language rule, a new definition
for identical argument types as an existing one will replace the old
definition rather than add a new overload. The realex response reflects this:

  Redefined inner_class: (LieType,[ratvec],string->InnerClass)
  Redefined inner_class: (RootDatum,string->InnerClass)

New meanings of operator symbols can also be defined in this way. So while
currently addition is only defined for integers and rationals, one could say

  set +(vec v,vec w) = vec: for vi@i in v do vi+w[i] od
  Added definition [4] of +: (vec,vec->vec)

to define addition of vectors. It is not possible though to introduce new
operator symbols or alternative priorities for the existing ones.

On the other an attempt to add a definition for a different but closely
related argument type may be refused, as in the following attempt to replace
[ratvec] by [[rat]]:

  set inner_class (LieType lt,[[rat]] gen,string ict)=
  inner_class(lt,for g in gen do ratvec: g od,ict)

gives the somewhat elaborate error message

  Cannot overload `inner_class', existing type
  (LieType,[ratvec],string) is close to (LieType,[[rat]],string),
  and either converts to the other, definition aborted.

If one really needs to replace the old definition, 'forget' must be used first.

Functions can also be unnamed values, which is particularly useful if the are
to be passed as arguments to other functions. So supposing g was defined by

expr> set g ((int->int) f) = vec: [f(0),f(f(1)),f(5)]
Defined g: ((int->int)->vec)

one could call g with the increment function without naming the latter:

expr> g((int n):n+1)
Value: [ 1, 3, 6 ]

One could define an identifier to have a function value using this syntax

expr> set f = (int n):n+1
Identifier f: (int->int)

but in this case the binding is stored in the ordinary (not overloaded)
identifier table. A new function value of the same type can now be assigned to
the same identifier 'f', to replace the old one, which is not possible with
overloaded function definitions. So function identifiers introduced in this
way behave as ordinary variables that happen to have a value of function type.

A global identifier defined with a function value in this way can coexist with
one or more overloaded instances for the same name, but this is not
recommended, as in makes the function value hard to call. Indeed when the name
is then used in function-call syntax, only the overloaded instances will be
tried. On the other hand if any local bindings of a name exist, this renders
all overloaded instances of the same name inaccessible. A consequence of this
rule is that one can force use of the non-overloaded value by writing

expr> let f=f { bind function-value locally to same name } in f(5)

8 Control structures

The language provides conditional expressions and loops. Both can deliver
values (which is somewhat unusual for loops), though they can also serve more
conventionally for selecting/iterating actions. Conditionals take the form

  if ... then ... else ... fi

for a simple 2-way branch, or a more elaborate multi-way branch

  if   ... then ...
  elif ... then ...
  elif ... then ...
  ...
  else ...
  fi

The expressions after 'then' and 'else' should all have the same type that
will become the type of the conditional expression (or they should be
implicitly convertible to the type expected for the conditional expression),
and exactly one of them will deliver the actual value of the conditional. The
branches can be formed of a list of expressions separated by ';', of which the
last one determines the value returned (and its type), while the preceding
ones have void type and deliver no useful value (but since every type can be
converted to void, any valid expression will be allowed for them). This is in
fact a separate construction, the "sequence expression", which can be used in
any place an expression is required (for instance a function argument),
although in some contexts parentheses around the sequence expression are
required to hold them together. The 'else' branch of a conditional may be
absent, but in that case the conditional delivers no value, and only servers
to select a branch for the side effects of its execution (for instance through
assignments). Indeed the parser substitutes an empty tuple '()' for the
else-branch in this case, and all other branches will be converted to its void
type in this case (just like expressions before ';' in a sequence expression).

In conditions (and in Boolean expressions in general) one can use connectives
'or', 'and' and 'not', which behave like operators of priority less than any
other ones except assignment (but increasing in the order given); they are
however handled in the parser, which will for instance transform 'x and y'
into 'if x then y else false fi' so they are not stored in any tables.

Loops come in various flavors, each one returning a row value with one
component for each iteration of the loop (except if the context demands a void
result). There are simple while loops

  while ... do ... od

with as usual a continuation condition after 'while'. If some pre-test action
is required on each iteration, it suffices to use a sequence expression as
continuation condition. The other expression is the loop body that determines
an entry of the row value returned by the loop; obviously at least one of the
component expressions must involve an action susceptible of changing the value
of the continuation condition if the loop is to terminate. So a loop

  let i=0 in while i<=n do i+:=1 od

will produce a row [1,2,...,n]. Often an advancement action is required to
take place after an entry of the result is contributed; to that end one has

  while ... do ... next ... od

where the entry is contributed before 'next', and the remaining expression is
only evaluated for its side effect (it has void type). So for instance

  let i=0 in while i<=n do i next i+:=i od

produces the row [0,1,...,n-1].

The remaining loops are 'for' loops, which determine the number of iterations
at the beginning rather than dynamically. The syntax is somewhat unusual, in
that it does not specify the starting and ending values of the iteration, but
rather the number of iterations and the smallest index; thus an iteration from
0 to n-1 is specified as n iterations with lowest index 0. More specifically,
one specifies (in this order) the number of iterations, the direction
(increasing or decreasing) and the lower bound of the range (only unit steps
are supported; a negative iteration count is interpreted as 0). The iteration
count is preceded by ':', the direction by the keyword 'from' (increasing) or
'downto' (decreasing), and the lower bound follows. The direction and lower
bound may be omitted, in which case 'from 0' is assumed. So

  for i : n from 0 do i od

is an alternative way to produce [0,1,...,n-1], and it may be abbrevieted

  for i : n do i od .

To obtain a more traditional range [1,2,...,n], one may say

  for i : n from 1 do i od .

For the reverse list [n-1,...,1,0] use

  for i : n downto 0 do i od

and the shifted reversed list [n,...,1] is produced by

  for i : n downto 1 do i od

As for the while loop, the body may be a sequence expression with side
effects, but assignments to the loop variable only have effect until the end
of the iteration; the next iteration is started at the next value in sequence.

Rather than counted iteration, it is often convenient to use iteration over an
existing composite value. If V is a row value, or vector or matrix then

  for e in V do ... od

iterates over the components of V (for a matrix these are its columns),
setting e to such a component before evaluating the loop body. For instance,
one can produce the scalar multiple by 3 of a vector V using

  vec: for e in V do 3*e od

(the 'vec:' serves to assemble the entries in a vector rather than a list).
In some cases it is useful to know the index of the component taken as well
inside the loop body, in other words the iteration count starting from 0; this
can be accessed by writing '@ index' before 'in' where 'index' is an
identifier used to bind the index to, This explains the vector addition above:

  set +(vec v,vec w) = vec: for vi@i in v do vi+w[i] od

where the index i is needed to select the corresponding entry from the other
vector. These value-returning loops are quite flexible, for instance

  mat: for j = n do for i = m do if i=j then 1 else 0 od od

produces an m*n matrix with unit diagonal entries and zeroes elsewhere. Of
course the case m=n of the identity matrix is most common, be we allowed
distinct values of m and n to stress that the column-oriented convention
forces the outer loop to be over the columns and the inner loop to be over the
rows. To add such a matrix to an existing matrix M it suffices to write

  for col@j in M do for entry@i in col do entry+if i=j then 1 else 0 fi od od

These for loops can iterate over every kind of composite value that allows
subscription, although one cannot iterate directly over matrix entries even
though these can be obtained directly by subscription (a for loop over a
matrix will iterate over its columns only; one could however do a nested loop
over the entries of that column as the last example above illustrates). One
special case of subscription is getting the (Split) coefficient of a given
Param value p in a ParamPol value pol; this coefficient can be written pol[p]
(and it will be 0+0s if p does not occur in pol). The for loop will then take
the usual form

  for c@p in pol do ... od

where each time c will be a nonzero coefficient and p the corresponding Param.

Conditionals can be used to do rudimentary recursive functions. The language
itself does not directly support recursion (a function expression has no means
to refer to itself from inside), but using assignment to a global function
variable we can nevertheless get recursion into place. The trick is to first
introduce a dummy function name with the correct type, so that the "recursive"
function body can pass the type check, and then by assignment replace it by a
properly recursive expression (note that the requirement that assignments do
not change types guarantees the type check continues to makes sense). An
ordinary function definition will not create a variable that can be assigned
to (instead it will enter an instance of the function name in the overload
table), so one must use a special form to create a function-valued variable.
Not using the overload table is forced by using the '<name> : <value>' syntax
instead of the 'let <name> = <value>' syntax. So the following works:

  expr> fac : (int n): 0
  Identifier fac: (int->int)
  expr> fac := ((int n): if n>0 then n*fac(n-1) else 1 fi);
  expr> fac(7)
  Value: 5040

The semicolon after the assignment to 'fac' serves to suppress printing of the
internal representation of the function object as value of the assignment.

Since the initial function value is to be never actually used (only its type
serves) one might as well not specify it at all, by writing as first line:

  expr> fac : (int->int)

This will give the global identifier 'fac' the indicated type but an undefined
value, with which nothing can be done except assigning another value of the
same type to it, which is exactly what we need for the recursive definition.
(One can use the same syntax to create undefined values of any type, but this
does not have much practical use, since a value must be supplied anyway before
it can be used.)

Often it is better to have the recursive function be local (introduced by
'let') to another definition. One reason for this would be to have the outer
function do some sanity check that should not be repeated recursively. Other
possible reasons are that the function to be defined should in fact be
overloaded with other instances of the same name (and the above approach as
said is not compatible with overloading), or that it should be bound to an
operator symbol (which symbols never refer to function-valued variables). For
local names the difficulty with the overload table disappears (they always
refer to assignable local variables). On the other hand the option of giving a
local name initially just a type but no value is not available: local
variables are created from values, so one must write a dummy function body.
One may define the factorial function using a local recursive function (called
'f' for clarity, to distinguish it from the global name 'fac') as follows:

  expr> set fac (int n) =
          if n<0 then error("Factorial of negative number")
          else let f(int i)=0
               in f:=((int n): if n>0 then n*f(n-1) else 1 fi)
             ; f(n)
          fi

(We have omitted the prompts after the first line.) Note that after the
assignment to 'f' one needs to apply the now defined recursive function to the
argument 'n' of the outer function, whence the 'f(n)'. Alternatively one might
have written '(f:=( ... )) (n)', applying the value of the assignment to 'n'.

9 Splitting commands across lines

Normally each line contains a command (an expression to evaluate, an
identifier or function definition, or a miscellaneous command) which is
executed as soon as the line is scanned and found to be syntactically correct
(and well typed). However various mechanisms are provided to allow commands to
extend across multiple lines. First of all, a command is not considered
complete if it contains unclosed parentheses or brackets, in which case it is
automatically extended to the following line. The unclosed symbols are
prefixed to the continuation prompt as an indication of what still needs to be
closed (unclosed string quotes are also tested for, but since strings cannot
contain newlines, they are simply closed by force at the end of the line). If
there are no unclosed parentheses or brackets but the line ends in a binary
operator or ':', then the line is also automatically continued. Finally the
user can force continuation of the line by typing '\' as the last non-space
character of the line (the backslash is removed, and actually joins the line
with the following one before analysis, so you could do this even to break in
the middle of an identifier or string or other token). Note that is the _only_
use of backslash as an escape character, anywhere else on the line it
designates the integer division-without-remainder operator (the forward slash
is division producing a rational number).


10 Output and input redirection

Some function calls return a value without printing anything, which value will
be printed by the interpreter (preceded by "Value:") if it is not assigned to
a variable or passed to another function. Other functions print output to the
terminal but do not return a useful value (the names to these functions start
with "print"). In either case the user may decide to write the result to a
file rather than to the terminal. To that end start the command line with ">"
or with ">>" followed by a file name (taken to be delimited by white space;
alternatively the file name may be enclosed in double quotes, in which case it
can contain spaces) followed by the (complex) function call producing the
desired output. In case of ">" a new file will be created, in case of ">>" the
output is appended to an existing file. For instance

  expr> >output_file block_sizes(ic)
  expr> >> output_file print_KGB(real_form(ic,2))
  expr> >> output_file print_KL_list(real_form(ic,2),dual_quasisplit_form(ic))
  expr>

will produce in the current directory the file 'output_file' with the results
of the indicated calls to block_sizes', 'print_KGB', and 'print_KL_list'.

One can also redirect command input from a file. Simply type

  expr> < filename

on a line by itself to execute the contents of 'filename' as a series of
commands. The output still goes to the terminal, unless the file contains
lines that themselves start with '>'. Note that, in spite of similar syntax,
output and input redirection have rather different characteristics. Output
redirection only applies to a single command, which must be an expression
evaluation (function call or variable, not an assignment or other statement).
Input redirection should not be followed by anything on the same line, but it
can invoke any number of commands from the given file. It can even be used
recursively to include commands from other files that are needed to process
the included file, it that file contains lines that start with '<'. One cannot
globally redirect the output produced from the commands of an included file.
If a command read from a file included at any level produces a syntax or
runtime error, a message reporting the place of the error is printed, all
included files are abandoned, and control is given back to the terminal.


11 Miscellaneous commands

Some operations, including the type checker, can be made more verbose by
giving the command

  expr> verbose

which remains in effect until a subsequent command

  expr> quiet

is given.


One can ask the state of all known identifiers by typing

  expr> showall

which prints the type and value of every defined function and variable. If one
just needs to know the type of one expression, one can type

  expr> whattype expr

This performs type analysis of the expression and prints the result, but does
not evaluate anything. Unfortunately, since an overloaded function name in
itself is not a valid expression, this cannot currently be used to find out
the types of functions; these types are however given by showall. Finally when
you get tired of using realex, type

  expr> quit
  Bye.


12 Syntax summary

A formal syntax is given in the parser generator source file "parser.y", which
should be fairly readable for those used to BNF syntax. Here we summarize its
contents informally.

The syntax is very largely centered around a single "part of speech", the
expression. There is no distinction between expressions and statements: every
expression may have side effects (if it contains assignments for instance) and
yields a value (although it might be void, or ignored). The only parts of the
syntax not directly concerned with expressions is the part defining commands,
which are only allowed at the outermost level, and some small categories such
as type specifications and formal parameter lists that are used to form
certain kinds of expressions without themselves being expressions. The command
level will be described at the beginning, the non-expressions categories at
the end. In between we enumerate the different kinds of expressions, in order
from most loosely bound to most tightly bound; using a loosely bound form in
more tightly bound context requires enclosing the expression in parentheses.

(a) Command level.

The most common command is an expression, possibly followed by a semicolon;
the result of evaluation will be printed if the semicolon is absent. Also
common is the 'set' command. In it's basic form 'set' is followed by a an
identifier pattern or an operator name, an '=' and an expression. For function
definitions there is an alternative form where 'set' is followed by a single
function name or operator symbol, a possibly empty parameter list in
parentheses, an '=', and an expression (the function body). In a parameter
list each parameter consists of a type followed by a non-empty parameter
pattern. Identifiers or operators of the 'set' command will be stored either
in the identifier table or in the overloading table; the latter will be chosen
whenever the expression given has a function type with at least one argument,
which must be the case when defining an operator symbol.

To get rid of an entry in the identifier table, the command 'forget name' can
be used. Individual instances in the overload table can also be removed (which
might be useful in case of overloading conflicts) using 'forget' with the
function or operator name followed by '@' and the argument type(s) as in
'forget +@(int,int)'. A shorter alternative to the syntax 'set x = expr' is
provided as 'x : expr'; if forces use of the identifier table. The latter
syntax with a type instead of expr creates a variable of the given type but
undefined value.

The command 'quit' terminates the interpreter, 'showall' shows all identifier
associations. The commands 'verbose' and 'quiet' turn on or off extra
diagnostics during expression analysis. A command starting with '>' or '>>'
redirects output to a file (appending in the latter case); the symbol is
followed by a file name (either delimited by whitespace or enclused in quotes)
and then the expression to be evaluated. Input redirection is similar, using
'<', but it should only be followed by a file name; if not found, the same
name with ".rx" appended will also be tried. Normally input redirection is
ignored if the same file was already read before; this is done so that a file
that buids forth on "basis.rx" can safely start with '<basis.rx' to ensure its
definitions are seen, without needlessly reloading it should it already have
been read. One can override this mechanism (useful if the file has changed) by
using '<<' instead of '<'. The command 'whattype' can either be followed by an
expression or by an identifier or operator followed by '?'. In the former case
the expression is only analyzed and its type printed; in the latter case the
overload table will be searched, and all occurrences of that item listed.

(b) Loose expressions: 'let', anonymous functions, casts, 'next'-expressions

These are the expression types that end with another expression, without ever
needing parentheses around that other expression; they are themselves loosely
bound, so the might require parentheses (or equivalently a begin-end pair)
around the entire expression if used in certain contexts (as right hand side
of an assignment for instance, or as item in a semicolon-separated sequence).
Let-expressions introduce local definitions: they start with 'let', then a
list of one or more definitions, then 'in', and finally an expression in which
those definitions are valid, and which produces the value of the construct.
Certain definitions in the list may be separated by 'then', which behaves like
'in let', so that the items defined before it are accessible afterwards.
Between two of 'let', 'then, and 'in', several definitions may be separated by
commas, in which case they are handled in parallel (neither can refer to the
identifiers defined by the others). Each basic definition consists of an
identifier pattern followed by '=' and an expression (which never needs
parentheses). Local definitions are never overloaded, and any locally defined
name hides all overloads of that name. Nevertheless the special syntax of
'set' for function definitions (with '=' after the parameter list) is also
available with 'let'; it defines a local name with a function as value.

Anonymous functions consist of a pair of parentheses enclosing a parameter
list, followed by an optional (result) type, and then ':' and the function
body expression. A parameter list consists of zero or more pairs of a type
followed by an identifier pattern, separated by commas. Other loosely bound
expressions are casts, consisting of a type followed by ':' and an expression.

A next-expression consists of a quaternary level expression followed by 'next'
and an expression. The 'next' separator behaves like ';', except that it
returns the value of its left hand expression (which is still evaluated first)
instead of its right hand expression. When more than two expressions are
separated by 'next', the one before the first 'next' determines the value.

(c) Quaternary expressions: semicolon-separated sequences.

A sequence of expressions separated by semicolons is evaluated from left to
right, and the value of the last expression determines the value of the
sequence (the values of the other expressions are cast away, and often not
even assembled; this is true for the right hand expression of 'next' as well).
Because semicolon binds more stringly than 'next', when using a mixture of
both (without parentheses to override) the final value comes from the last
expression before the first 'next'. Also because semicolon binds more stringly
than for instance let expressions or casts, those need to be parenthesized
when occurring in a semicolon-separated sequence. Tertiary expressions are
even more strongly bound than quaternary expressions, and so on, so all these
types of expressions require parentheses around quatrenary subexpressions.

(d) Tertiary expressions: assignments and Boolean expressions.

Assignments change the values bound to (non-overloaded instances of) local or
global identifiers (the most local binding hides any others). They consist of
an identifier name, then ':=' and a tertiary expression. The identifier must
have been introduced before (at least one binding must be found), and the
assignment must be compatible with its type, which cannot change by the
assignment (but the assigned value might be converted to match the type). An
alternative form of the assignment allows a binary operator symbol before ':='
as abbreviation, where an assignment like 'a % := 7' stands for 'a := a % 7'.
Another form of assignment involves a subscripted left hand side: an
identifier followed by '[', one or two expressions separated by ',', and
finally ']'. This modifies a list, vector or matrix by replacing one entry or
(in case of a matrix used with only one index expression) column by the value
of the right hand expression. The effect is that of the assignment of a new
value to the identifier, which differs from the old value only in the place
specified by the index or indices.

Boolean expressions involve the logical connectives 'and', 'or' and 'not'.
They can be understood as the most loosely bound forms of expressions, but are
actually translated into if-then-else expressions with Bollean values:
x and y -> if x then y else false fi,  x or y -> if x then true else y fi,
not x -> if x then false else true fi. This implies that the right hand side
of 'and ' and 'or' connectives is only evaluated if necessary. The connective
'or' is most loosly bound, 'and' binds stronger and 'not' stronger still, but
all of them bind more loosly then formulas, notably comparison operations.

(e) Secondary expressions: formulas.

These involve operators in the following order of increasing priority:
=,  !=,  <,  >,  <=,  >=;        +, -;      *, /, \, %, \%;     ^;        #.
Items separated by commas have the same priority, while among operators of the
same priority association is from left to right, except for '^' right to left.
When used in a unary way, an operator binds with the same priority and when
used as a binary operator: -x+y is (-x)+y, -a^b is -(a^b), and -a%p is -(a%p).

(f) Primary expressions: subscriptions, function applications, units

Subscriptions consist of a primary expression (usually an identfier) followed
by an index expression (or in cas of matrix subscription, by two expressions
separated by a comma) enclosed in '[' and ']'. Function applications are
similar except that the list of (argument) expressions is encloded in '(' and
')', and that it may be of arbitrary length, possibly empty. Units are
expressions made of a single symbol: an identifier, integer number, true,
false, or string constant (enclosed in quotes and on a single line). These are
primary expressions, as are specialisations of overloaded names or operators,
formed by following the name or operator by '@' and a type (as in 'forget').

(g) Closed expressions: displays and groupings, conditionals, loops

These compound expressions include delimiters at both ends, so they never need
(additional) paretheses; a single parenthesized expression also forms a closed
expression. The different forms are as follows, where '*' is any expression

if * then * fi		  	which abbreviates: if * then * else () fi)
if * then * else * fi
if * then * elif * then ... fi
while * do * od
for pattern in * do * od
for pattern @ ident in * do * od
for ident : * do * od
for ident : * from * do * od
for ident : * downto * do * od
begin * end			which is equivalent to: ( * )
( * , * , ... )			which builds a tuple
[ * , ... ]   			which builds a list
[ * , ... | * , ... | ... ]     which builds a matrix by rows

(h) Argument lists, Identifier patterns

An identifier pattern can be a single identifier, or a parenthesized list or a
parenthesized list followed by ':' and an identifier (naming the whole
structure); in case of a parenthesized list the type of the expression that is
to be bound to the pattern should have the corresponding tuple structure. The
items in the parenthesized list are again patterns, separated by commas, where
patterns may also be omitted if no name is needed for the corresponding
component (contrary to argument lists that require each argument to be named).

(i) Types

Types are either 'void' (the type of the empty tuple) or recursively
constructed using the basic types 'int', 'bool', 'string', 'vec', 'mat',
'ratvec', or atlas-specific types like 'InnerClass', using the list
constructor [*], the tuple constructor (*,*,...) (with at least two types:
around a single type parentheses just provide redundant grouping) and the
function constructor (*,*,...->*,*,...) (here parentheses around argument and
result type lists are implicitly assumed if there are more than one; there
could be none at all, which is equivalent to specifying 'void').
