set #(int n)= [int]: for i:n do i od       { [0,1,...,n-1] }
set #(bool b) = int: if b then 1 else 0 fi { Iverson symbol }
set #(ratvec v)= int: let (n,)=%v in #n    { length }

set n_rows(mat m)= int: let (r,)=#m in r
set n_columns(mat m)= int: let (,c)=#m in c

set != ((string,string)p) = bool: not =p
set > ((string,string)p) = bool: not <=p
set >= (string x, string y) = bool: y<=x
set < (string x, string y) = bool: y>x
set *(string s, int n)= string: let r="" in (for i:n do r#:=s od; r)

{fix > for rational numbers, -1/1>0 gave wrong answer}
set > (rat r,rat s)=let (a,b)=%r then (c,d)=%s in a*d-b*c>0
set >= (rat r,rat s)=let (a,b)=%r then (c,d)=%s in a*d-b*c>=0

set *(int c,vec v) = vec: for e in v do c*e od
set *(int c,mat m) = mat: for col in m do for e in col do c*e od od

set +(string s, int i)= string: s # int_format(i)
set +(int i, string s)= string: int_format(i) # s
set +(string s,string t) = string: s # t { alias for concatenation }

set ^ =
  let matrix_power (mat m,int n)= mat: m { dummy for recursion }
  then () = matrix_power := { assign recusive function body }
    ( (mat m,int n): { we hall have n>0 }
      if n=1 then m
      else let (q,r)=n\%2 then mm=matrix_power(m,q) in
	mm*if r=0 then mm else mm*m fi
      fi
    )
  in { operator ^ = } (mat m,int n) mat:
  if n>0 then matrix_power(m,n) elif n=0 then id_mat(n_rows(m))
  else error("Negative matrix power "+n)
  fi

set -(vec w)= vec: for e in w do -e od
set -(mat m)= mat: for c in m do for e in c do -e od od

set +(vec v,vec w)= vec:
( if #v != #w then error("Size mismatch " + #v + ":" + #w) fi
; for e@i in v do e+w[i] od
)

set -(vec v,vec w)= vec:
( if #v != #w then error("Size mismatch " + #v + ":" + #w) fi
; for e@i in v do e-w[i] od
)

set %(vec v,int d) = vec: for x in v do x%d od

set sum (vec v)= let s=0 in for e in v do s+:=e od; s
set product (vec v)= let s=1 in for e in v do s*:=e od; s

set sum (mat m)= { sum of columns of m }
  let (r,)=#m then sum = null(r) in for col in m do sum+:=col od; sum

set +(string s, (int,int)(x,y)) = s + "(" + x + "," + y + ")"

set floor (rat a) = \ %a
set ceil  (rat a) = -\ %-a

{absolute value and sgn of integer}
set abs (int k)=if k<0 then -k else k fi
set sgn (int k)=if k<0 then -1 else 1 fi

set numer (rat a) = let (n,)=%a in n
set denom (rat a) = let (,d)=%a in d
set numer (ratvec a) = let (n,)=%a in n
set denom (ratvec a) = let (,d)=%a in d
set =(ratvec v,ratvec w) = let (n,d)=%v, (m,e)=%w in e*n=d*m
set -(ratvec v) = let (n,d)=%v in (-n)/d
set *(int m,ratvec v) = let (n,d)=%v in m*n/d
set /(ratvec v,int m) = let (n,d)=%v in n/(m*d)
set *(rat r,ratvec v) = let (n,d)=%r, (nv,dv)=%v in (n*nv)/(d*dv)
set *(ratvec r, vec v) = let (n,d)=%r in n*v/d

set floor ([rat] v) = for a in v do floor(a) od
set ceil  ([rat] v) = for a in v do  ceil(a) od

set = ((int,int)(x0,y0),(int,int)(x1,y1)) = bool: x0=x1 and y0=y1
set !=((int,int)(x0,y0),(int,int)(x1,y1)) = bool: x0!=x1 or y0!=y1

set = (Split x,Split y) = %x = %y
set != (Split x,Split y) = %x != %y

set s = Split:(0,1)
set + (Split x) = let (r,)=%x in r { real part }
set ^ (Split x) = let (,y)=%x in y { s part }

set split_power = (Split,int->Split):
let p = (Split x,int n): x
in p:= ((Split x,int n): { we shall have n>0 }
  if n=1 then x
  else let (q,r)=n\%2 then y=p(x,q) in y*if r=0 then y else x*y fi
  fi)
set ^(Split x,int n) =
  if n>0 then split_power(x,n) elif n=0 then Split:(1,0)
  elif let (a,b)=%x in abs(a)+abs(b)=1 then if n%2=0 then 1 else x fi
  else error("Negative power "+n+" of split integer")
  fi

set -(ParamPol a, (Split,Param) (c,p)) = ParamPol: a+(-c,p)

{ these cases are handled by the coercion code, so they have been removed
set +(ParamPol a, (int,Param) (c,p)) = ParamPol: a+(Split:  c,p)
set -(ParamPol a, (int,Param) (c,p)) = ParamPol: a+(Split: -c,p)
}

set +(mat M,mat N)= mat:
( if #M != #N then error("Size mismatch " + #M + ":" + #N) fi
; for col@j in M do for e@i in col do e+N[i,j] od od
)

set -(mat M,mat N)= mat:
( if #M != #N then error("Size mismatch " + #M + ":" + #N) fi
; for col@j in M do for e@i in col do e-N[i,j] od od
)

set min (int k, int l) = int: if k<l then k else l fi
set max (int k, int l) = int: if k<l then l else k fi

set ones(int n)= vec: for i:n do 1 od

set rho (RootDatum rd) = ratvec:
( let res= ratvec: null(rank(rd))
  in for i:semisimple_rank(rd) do res +:= fundamental_weight(rd,i) od
; res
) { uses fewer additions than computing half sum of the positive roots }

set imaginary_roots (RootDatum rd, mat theta) = mat:
( let ir = [vec]: [] in
  for alpha in roots(rd) do if theta*alpha = alpha then
    ir #:= alpha
  fi od
; if #ir=0 then null(rank(rd),0) else ir fi
)

set real_roots (RootDatum rd, mat theta) = mat:
( let rr = [vec]: [] in
  for alpha in roots(rd) do if theta*alpha = -alpha then
     rr #:= alpha
  fi od
; if #rr=0 then null(rank(rd),0) else rr fi
)

set imaginary_coroots (RootDatum rd, mat theta) = mat:
( let ic = [vec]: [] in
  for alpha in coroots(rd) do if alpha*theta = alpha then
    ic #:= alpha
  fi od
; if #ic=0 then null(rank(rd),0) else ic fi
)

set real_coroots (RootDatum rd, mat theta) = mat:
( let rc = [vec]: [] in
  for alpha in coroots(rd) do if alpha*theta = -alpha
    then rc #:= alpha
  fi od
; if #rc=0 then null(rank(rd),0) else rc fi
)

set simple_reflection (RootDatum rd, int s) = mat: { s indexes simple root }
  id_mat(rank(rd))- [simple_roots(rd)[s]] * ^[simple_coroots(rd)[s]]

set reflection (RootDatum rd, int alpha) = mat: { alpha indexes any root! }
  id_mat(rank(rd))- [roots(rd)[alpha]] * ^[coroots(rd)[alpha]]

set != (InnerClass x,InnerClass y) = bool: not(x=y)

set involution (InnerClass ic, [int] tw) = mat: { tw is a Weyl word }
( let rd = root_datum(ic), theta = distinguished_involution(ic)
  in for i : #tw downto 0 do theta := simple_reflection(rd,tw[i])*theta od
  ; theta
)

set imaginary_roots (InnerClass ic, [int] tw) = mat:   { tw is a Weyl word }
  imaginary_roots(ic,involution(ic,tw))
set real_roots (InnerClass ic, [int] tw) = mat:        { tw is a Weyl word }
  real_roots(ic,involution(ic,tw))
set imaginary_coroots (InnerClass ic, [int] tw) = mat: { tw is a Weyl word }
  imaginary_coroots(ic,involution(ic,tw))
set real_coroots (InnerClass ic, [int] tw) = mat:      { tw is a Weyl word }
  real_coroots(ic,involution(ic,tw))

{ integrality inner class (dual side) defined by inf. character and involution }
set dual_integral(InnerClass ic, ratvec gamma) = InnerClass:
  inner_class(dual(integrality_datum(ic,gamma)),-^distinguished_involution(ic))

set = (RealForm f, RealForm g) = bool:
  inner_class(f) = inner_class(g) and form_number(f)=form_number(g)
set != (RealForm f, RealForm g) = bool: not(f=g)

set -(ParamPol P,ParamPol Q) = ParamPol: P+(-1)*Q
set =(ParamPol P,ParamPol Q) = bool: #(P-Q)=0

{ order of operands in the next function avoids conflicting *@(int,ParamPol) }
set *(Param p,rat alpha) = let (x,lambda,nu)=%p in param(x,lambda,alpha*nu)

{need some overloads since coercion RealForm->InnerClass or RootDatum is disabled}
set root_datum(RealForm G)=root_datum(inner_class(G))
set semisimple_rank(RealForm G)=semisimple_rank(root_datum(G))
set roots(RealForm G)=roots(root_datum(G))
set coroots(RealForm G)=coroots(root_datum(G))
set nr_of_Cartan_classes(RealForm G)=nr_of_Cartan_classes(inner_class(G))
set nr_of_real_forms(RealForm G)=nr_of_real_forms(inner_class(G))
set distinguished_involution(RealForm G)=distinguished_involution(inner_class(G))
set positive_roots(RealForm G)=positive_roots(root_datum(G))
set simple_roots(RealForm G)=simple_roots(root_datum(G))

set KGB(RealForm rf) = [KGBElt]: for i:KGB_size(rf) do KGB(rf,i) od
set is_complex(int s,KGBElt x) = status(s,x)%4=0
set is_real(int s,KGBElt x) = status(s,x)=2
set is_imaginary(int s,KGBElt x) = status(s,x)%2=1
set is_noncompact(int s,KGBElt x) = status(s,x)=3
set is_compact(int s,KGBElt x) = status(s,x)=1
set is_descent(int s,KGBElt x) = status(s,x)<3
set is_ascent(int s,KGBElt x) = status(s,x)>=3
set status_code(int s,KGBElt x) = ["C-","ic","r ","nc","C+"][status(s,x)]
set status_codes(KGBElt x) =
  for s:semisimple_rank(real_form(x)) do status_code(s,x) od
set x(Param p) = KGBElt: let (x,,) =%p in x {so don't have to load misc.rx}
set status_code(int s,Param p)=status_code(s,x(p))
set status_codes(Param p)=status_codes(x(p))

set imaginary_type(int s, Param p)=if cross(s,Cayley(s,p))=Cayley(s,p) then 1 else 2 fi
set real_type(int s,Param p)=imaginary_type(s,Cayley(s,p))

set is_parity(int s,Param p)=bool: if status_code(s,x(p))="r " then inv_Cayley(s,p)=p else false fi
set is_non_parity(int s,Param p)=bool: if status_code(s,x(p))="r " then not(is_parity(s,p)) else false fi

set full_status_code(int s,Param p)=string:
if is_real(s,x(p)) then 
 if is_parity(s,p) then "rn" else ["r1","r2"][real_type(s,p)-1] fi
elif is_noncompact(s,x(p)) then ["i1","i2"][imaginary_type(s,p)-1] else
status_code(s,x(p)) fi

set full_status_codes(Param p)=[string]:for s:semisimple_rank(real_form(p)) do full_status_code(s,p) od

set in_tau(int s,Param p)=bool:if is_compact(s,x(p)) or status_code(s,x(p))="C-" or is_non_parity(s,p) then true else false fi
set tau(Param p)=let rv=[] in for s:semisimple_rank(real_form(p)) do if in_tau(s,p) then rv:=rv#s fi od;rv
set in_tau_complement(int s,Param p)=bool:not(in_tau(s,p))
set tau_complement(Param p)=let rv=[] in for s:semisimple_rank(real_form(p)) do if in_tau_complement(s,p) then rv:=rv#s fi od;rv

set null_module(Param p)=ParamPol:null_module(real_form(p))
set null_module(ParamPol P)=ParamPol:null_module(real_form(P))

{ define dot product ratvec*ratvec,ratvec*vec,vec*ratvec }
set *(ratvec v,ratvec w)= rat: let (a,b)=%v then (c,d)=%w in a*c/(b*d)

set singular_roots(RootDatum rd,ratvec v)=[int]:
let rv=[] in for a@i in simple_coroots(rd) do if a*v=0 then rv:=rv#i fi od;rv

{some necessities now that implicit conversion Param->ParamPol is disabled}
set virtual(Param p)=ParamPol:null_module(real_form(p))+p
set *(int n,Param p)=ParamPol:n*virtual(p)
set -(Param p)=ParamPol:(-1)*p
set -(ParamPol P,Param p)=ParamPol:P+(-1)*virtual(p)
set +(Param p,Param q)=ParamPol:virtual(p)+virtual(q)
set -(Param p,Param q)=ParamPol:virtual(p)+(-1)*virtual(q)