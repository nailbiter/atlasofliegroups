<basic
<det

{ test if an integer is even, or a rational is an integer }
set is_even (int i)    = bool: i%2=0
set is_odd (int i)    = bool: not is_even(i)
set is_integer (rat r) = bool: denom(r)=1
set is_positive (rat r)=bool: r>0
set is_nonnegative (rat r)=bool: r>=0

{ test if a ratvec is in fact a vec (integers)}
set is_integer (ratvec v) = bool: denom(v)=1
set is_positive (ratvec v)=let positive=true in for r in v do positive:=(positive and r>0) od;positive
set is_nonnegative (ratvec v)=let nonnegative=true in for r in v do nonnegative:=(nonnegative and r>=0) od;nonnegative

{ make a rational into an integer if possible }
set rattoint (rat r) = int:
  let (n,d)=%r in if d=1 then n else error("Not an integer") fi

{ make a rational vector into an integer one if possible }
set ratvectovec([rat] v)=vec:let (w,d)=%v in if d=1 then w else error("Not an integer vector") fi

{ define dot product ratvec*ratvec,ratvec*vec,vec*ratvec  moved to basic.rx}
{set *(ratvec v,ratvec w)= rat: let (a,b)=%v then (c,d)=%w in a*c/(b*d)}

{ transform ParamPol into a list of (Split,Param) pairs; previously built-in }
set %(ParamPol P) = [(Split,Param)]: for c@p in P do (c,p) od

{ cases *@(vec,ratvec) and *@(ratvec,vec) are now handled by coercion }

set root_datum(Param p)=RootDatum: root_datum(real_form(p))
set root_datum(ParamPol P)=RootDatum: root_datum(real_form(P))

set is_dominant(RootDatum rd, ratvec v)=bool:is_nonnegative(numer(v)*simple_coroots(rd))
set is_regular(RootDatum rd,ratvec v)= bool:
let w=numer(v)*simple_coroots(rd) in let regular=true in for r in v do regular:=(regular and r!=0) od;regular
set is_strictly_dominant(RootDatum rd, ratvec v)=bool:is_dominant(rd,v) and is_regular(rd,v)

{ test if rartional weight (not necessarily dominant) is regular }
set is_regular(RootDatum rd,ratvec lambda)= bool:
  let regular=true
  in for alpha in positive_coroots(rd) do
       if alpha*lambda=0 then regular:=false fi
     od; regular

set is_regular(RealForm G,ratvec lambda)=is_regular(root_datum(G),lambda)
set is_regular(Param p)=is_regular(real_form(p),infinitesimal_character(p))

set rho(RealForm G)=rho(root_datum(G))
set rhocheck(RootDatum rd)= ratvec: rho(dual(rd))
set rhocheck(RealForm G)  = ratvec: rhocheck(root_datum(G))

{ make rho as a vector of integers if possible }
set intrho (RealForm G) = vec: ratvectovec(rho(G))
set intrho (RootDatum r)= vec: ratvectovec(rho(r))

{ some data defined by a Param p }
set integrality_datum(Param p)= RootDatum:
  integrality_datum(root_datum(p),infinitesimal_character(p))

{ extract x,lambda-rho,lambda,nu from p
  lambda-rho =vec,  lambda= ratvec }
set x(Param p) = KGBElt: let (x,,) =%p in x
set lambdaminusrho(Param p) = vec: let (,lambda,) =%p in lambda
set lambda(Param p) = ratvec: lambdaminusrho(p)+rho(real_form(p))
set nu(Param p) = ratvec: let (,,nu) =%p in nu

{ alternate syntax for param command:
  param(G,3,...) instead of param(KGB(G,3),...)  }
set param(RealForm G,int k, vec lambda,ratvec nu)=param(KGB(G,k),lambda,nu)

{ normparam(G,x,lambda,nu)=param(G,x,lambda-rho(G),nu), so you can enter
  lambda without the rho shift, lambda may have denominator 2}
set normparam (RealForm G,int x,ratvec lambda,ratvec nu)=Param:param(G,x,ratvectovec(lambda-rho(G)),nu)
set normparam (KGBElt x,ratvec lambda,ratvec nu)=Param:param(x,ratvectovec(lambda-rho(real_form(x))),nu)



{ get just the parameters from a block, just a shorcut to: (params,)=block(p) }
set get_block (Param p) = [Param]: let (params,)=block(p) in params


{ replace non-final parameter with [Param p] of final ones
  uses this feature of ParamPol, but ignores any coefficients }
set make_final (Param p)= [Param]: for  c@q in null_module(real_form(p))+p do q od

{ nicer display of Splits }
set prettyPrint (Split w) = string:
  let (a,b)=%w in
  if   b=0 then int_format(a)
  elif a=0 then
       if b=1 then "s" elif b=-1 then "-s" else int_format(b)#"s" fi
  elif b=1 then int_format(a)#"+s"
  elif b=-1 then int_format(a)#"-s"
  elif b<-1 then int_format(a)#int_format(b)#"s"
  else int_format(a)#"+"#int_format(b)#"s"
  fi

{ nice output of ParamPol:
  prettyPrint the coefficients, print terms in order of x }
set prettyPrint (ParamPol P)= void:
for w@p in P
do prints("(",prettyPrint(w),")*",p,", ",infinitesimal_character(p)) od

{ evaluate at s=t for t integer (or rational?): replace w=a+bs with a+bt }
{ would seem to make sense only if t^2=1, so if either t=1 or t=-1 }
set  #(Split w,int t)=let (a,b)=%w in int: a+t*b
set  #(Split w,rat t)=let (a,b)=%w in rat: a+t*b
set  #(ParamPol P,int t)= ParamPol: { with integer coefficiens }
  null_module(real_form(P)) +  for w@q in P do (w#t,q) od

{ evaluate polynomial at split }
set eval(vec v,Split w)= Split:
  let sum=Split:0 in  for i:#v downto 0 do sum:= v[i] + w*sum od; sum

set at_s(vec v)=eval(v,s)

{ evaluate polynomial at integer }
set eval(vec v,int k)= int:
  let sum=0 in  for i:#v downto 0 do sum:= v[i] + k*sum od; sum

set fundamental_Cartan(RealForm G)=CartanClass:Cartan_class(G,0)
set most_split_Cartan(RealForm G)=CartanClass:Cartan_class(G,nr_of_Cartan_classes(G)-1)

{properties of groups}

set fiber_part(RealForm G)=fiber_part(Cartan_class(G,0),G)

set in_distinguished_fiber(KGBElt x)=bool:involution(x)=distinguished_involution(real_form(x))

set distinguished_fiber(RealForm G)=[int]:
let done=false in 
let rv=[] in 
let i=0 in 
while i<KGB_size(G) do  if in_distinguished_fiber(KGB(G,i)) then rv#:=i;i:=i+1 else i:=KGB_size(G) fi od;rv

set rank(RealForm G)=rank(root_datum(G))

set semisimple_rank(RealForm G)=semisimple_rank(root_datum(G))
set rank(RealForm G)=rank(root_datum(G))

set ss_rank(RootDatum rd)= semisimple_rank(rd)
set ss_rank(RealForm G)= semisimple_rank(G)

set dimension(RealForm G)=n_columns(roots(G))+rank(G)

set length(RootDatum rd,vec alpha)=int:rattoint(alpha*rhocheck(rd))
set is_simple(RootDatum rd,[int] alpha)=bool:length(rd,alpha)=1

set get_simple_number(RootDatum rd,vec alpha)=
let rv=-1 in 
let i=0 in 
while i<ss_rank(rd) do  if alpha=simple_roots(rd)[i] then rv:=i;i:=ss_rank(rd) else i:=i+1 fi od;rv

set reverse (vec v)= vec: for i:#v downto 0 do v[i] od

{lists of simple roots, coroots}
set extract_simple_roots_and_coroots(mat positive_roots,mat positive_coroots)=(mat,mat):
let tworho=sum(positive_roots) in 
let tworhocheck=sum(positive_coroots) in 
let (simple_roots,simple_coroots)=([],[]) in
(for alpha in positive_roots do if alpha*tworhocheck=1 then simple_roots#:=alpha fi od,
 for alphacheck in positive_coroots do if alphacheck*tworho=1 then simple_coroots#:=alphacheck fi od);(simple_roots,simple_coroots)

set extract_positive_roots(RootDatum rd, mat set_of_roots)=mat:
let rv=[] in let rhocheck=rhocheck(rd) in for a in set_of_roots do if a*rhocheck>0 then rv#:=a fi od;rv

set extract_positive_coroots(RootDatum rd, mat set_of_coroots)=mat:
let rv=[] in let rho=rho(rd) in for a in set_of_coroots do if a*rho>0 then rv#:=a fi od;rv

set imaginary_roots_and_coroots (RootDatum rd, mat theta) = (mat,mat):
( let im_roots = [vec]: [],im_coroots=[vec]:[],roots=roots(rd), coroots=coroots(rd) in
  for alpha@i in roots do if theta*alpha = alpha then
    (im_roots #:= alpha, im_coroots#:=coroots[i]) 
  fi od
; if #im_roots=0 then (null(rank(rd),0),null(rank(rd),0)) else (im_roots,im_coroots) fi
)
set imaginary_roots_and_coroots (KGBElt x) = (mat,mat):imaginary_roots_and_coroots (root_datum(real_form(x)),involution(x))

set positive_imaginary_roots_and_coroots (RootDatum rd, mat theta) = (mat,mat):
( let im_roots = [vec]: [],im_coroots=[vec]:[],roots=positive_roots(rd), coroots=positive_coroots(rd) in
  for alpha@i in roots do if theta*alpha = alpha then
    (im_roots #:= alpha, im_coroots#:=coroots[i]) 
  fi od
; if #im_roots=0 then (null(rank(rd),0),null(rank(rd),0)) else (im_roots,im_coroots) fi
)
set positive_imaginary_roots_and_coroots (KGBElt x) = (mat,mat):positive_imaginary_roots_and_coroots (root_datum(real_form(x)),involution(x))

set real_roots_and_coroots (RootDatum rd, mat theta) = (mat,mat):
( let im_roots = [vec]: [],im_coroots=[vec]:[],roots=roots(rd), coroots=coroots(rd) in
  for alpha@i in roots do if theta*alpha = -alpha then
    (im_roots #:= alpha, im_coroots#:=coroots[i]) 
  fi od
; if #im_roots=0 then (null(rank(rd),0),null(rank(rd),0)) else (im_roots,im_coroots) fi
)

set real_roots_and_coroots (KGBElt x) = (mat,mat):real_roots_and_coroots (root_datum(real_form(x)),involution(x))

set positive_real_roots_and_coroots (RootDatum rd, mat theta) = (mat,mat):
( let im_roots = [vec]: [],im_coroots=[vec]:[],roots=positive_roots(rd), coroots=positive_coroots(rd) in
  for alpha@i in roots do if theta*alpha = -alpha then
    (im_roots #:= alpha, im_coroots#:=coroots[i]) 
  fi od
; if #im_roots=0 then (null(rank(rd),0),null(rank(rd),0)) else (im_roots,im_coroots) fi
)

set positive_real_roots_and_coroots (KGBElt x) = (mat,mat):positive_real_roots_and_coroots (root_datum(real_form(x)),involution(x))

set split_rank(RealForm G)=int:
let ((c,C,s),,,)=Cartan_info(most_split_Cartan(G)) in C+s

addone:([int],int->[int])
addone:=(([int] v, int k):
let rv=if k>=#v then null(#v) elif
v[#v-k-1]=0 then v[#v-k-1]:=1;v else
v[#v-k-1]:=0;addone(v,k+1) fi in rv);

set generate_all_binary(int n)=[vec]:
let v=null(n) then
rv=[v] in
let ()=for i:2^n-1  do v:=addone(v,0);rv:=rv#v od in rv

set generate_all_subsets([int] S)=
let b=generate_all_binary(#S) in
for x in b do 
 let rv=[] in for i:#x do if x[i]=1 then rv:=rv#S[i] else rv:=rv  fi od;rv od  
