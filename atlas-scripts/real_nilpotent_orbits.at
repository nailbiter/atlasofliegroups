<knilpotent.at
set real_verbose=false

{ComplexNilpotent is (RootDatum rd,vec H)
 RealNilpotent is (KGBElt x,vec H) where theta_x(H)=H
}
:RealNilpotent=(KGBElt,vec)

set x(RealNilpotent O)=KGBElt:let (x,)=O in x
set H(RealNilpotent O)=vec:let (,H)=O in H

set dim_nilpotent(RealNilpotent O)=int:dim_nilpotent(real_form(x(O)),H(O))

set complex_nilpotent(RealNilpotent (x,H))=(root_datum(x),H)
set diagram(RealNilpotent O)=diagram(complex_nilpotent(O))
set semisimple_element(RealNilpotent (,H))=H
set real_form(RealNilpotent (x,))=real_form(x)

set zero_roots(RootDatum rd,vec v)=let rv=[] in for a@i in simple_roots (rd) do if a*v=0 then rv#:=i fi od;rv
set delete([(KGBElt,vec)] P, int k)=[(KGBElt,vec)]:P[:k]#P[k+1:]

set multiplier=1
set real_nilpotent_orbits(RealForm G,[(KGBElt,vec)] all_x_H_pairs,int N)=
([(KGBElt,vec)],    {list of (x,H) pairs}
 [(KGBElt,vec,Param,KParamPol)],     {corresonding mus}
 [( (KGBElt,vec),[(KGBElt,vec,Param,KParamPol)],[int],[int])]):   {[ ( bad_x_H_pair,mus,coeffs)]}
let x_0=KGB(G,0) then
not_valid=[((),[(KGBElt,vec,Param,KParamPol)]:[],[int]:[])] then
theta=distinguished_involution(G) then
(x,H)=all_x_H_pairs[0]  then
L=Levi_alt(H,x) then
Kparams=all_K_parameters_norm_less_than(L,rho_check(G),N) then
mus=[(KGBElt,vec,Param,KParamPol)]:[] in
let ()=for p in Kparams do
{ let ()=prints("K_norm of p:", K_norm(rho_check(G),p)) in}
 let m=mu(x,H,p) in
 let max=K_norm(m) in
{ let ()=prints("maximal K_norm of m:", max) in }
 let (x_L,lambda_L)=p in
 let p_L=parameter(x_L,lambda_L) in
 if max<multiplier*N then mus#:=(x,H,p_L,m) fi od then
valid_x_H_pairs_start=[(x,H)] then
{()=prints("knorms of mus:");prints(for (,,,mu) in mus do K_norm(mu) od) then}
mus_start=mus then
todo_start=delete(all_x_H_pairs,0) in
{let ()=prints("todostart:", todo_start) in}
let rec_fun f([(KGBElt,vec)] valid_x_H_pairs,
[(KGBElt,vec)] todo,
[(KGBElt,vec,Param,KParamPol)] mus,
[((KGBElt,vec),[(KGBElt,vec,Param,KParamPol)],[int],[int])] not_valid)=
([(KGBElt,vec)],
 [(KGBElt, vec,Param,KParamPol)],
[((KGBElt,vec),[(KGBElt,vec,Param,KParamPol)],[int],[int])]):
{let ()=prints("in function f with:", mus, "todo= ", todo) in}
if #todo=0 then (valid_x_H_pairs,mus,not_valid) else
let (x,H)=todo[0] then
()=if real_verbose then prints();prints("Doing (x,H)=(", number(x), ",",H,")") fi then
todo=delete(todo,0) then
new_mu=mu(x,H) in
{let ()=prints("Computed new_mu using ", x, "  H=",H) in}
{let ()=prints("K_norm of new_mu", K_norm(new_mu)) in}
let mus_only = for (,,,mu) in mus do mu od in
{let ()=prints("SIZE OF MUS:", #mus_only) in}
let (inspan,new_R,new_S,new_T)=in_span(mus_only,new_mu)
in if inspan then
prints("not valid:", x, H, " ", diagram(G,H));
{prints("looked for:", new_mu);}
let new_quads=[] in
let ()=for j:#new_T do if new_T[j]!=0 then
new_quads#:=mus[j] fi od in
not_valid#:=((x,H),new_quads,new_S,new_T)
else
valid_x_H_pairs#:=(x,H);
let ()=prints("valid:",x,H, " ", diagram(G,H)) in
let L=Levi_alt(H,x) in let
 params=all_K_parameters_norm_less_than(L,rho_check(G),N) in
{ let ()=prints("got new params ",#params) in}
 let new_mus=[(KGBElt,vec,Param,KParamPol)]:[] in
 for p in params do
{ let ()=prints("computing mu of ",p, " for ", real_form(parameter(p)),  " of norm ", K_norm(p)) in}
 let m=mu(x,H,p) in
 let max=K_norm(m) in
{ let ()=prints("max=",max) in}
 if K_norm(m)<=multiplier*N then
{   let ()=prints("added mu:", x, " ", H, " ", p) in}
   let (x_L,lambda_L)=p in let p_L=parameter(x_L,lambda_L) in
 new_mus#:=(x,H,p_L,m) fi od;
 mus#:=new_mus fi;
f(valid_x_H_pairs,todo,mus,not_valid) fi
in let empty=[((KGBElt,vec),[(KGBElt,vec,Param,KParamPol)],[int],[int])]:[] in
f(valid_x_H_pairs_start,todo_start,mus_start,empty)

set all_x_H_pairs(RealForm G)=[(KGBElt,vec)]:
let theta=distinguished_involution(G) then
all_complex_H=[vec]:[]  then
()=for (H,) in all_H(G) do if ^theta*H=H  then all_complex_H#:=H fi od then
all_x_H_pairs=[(KGBElt,vec)]:[] then
()= for H in all_complex_H do
  let P=zero_roots(G,H) then
  parabolics=all_theta_stable_parabolics_type(G,P) then
  kgb_elements=for Q in parabolics do Q[0] od then
  ()=for x in kgb_elements do all_x_H_pairs#:=(x,H) od in 1
od in all_x_H_pairs


set real_nilpotent_orbits(RealForm G,int N)=
([(KGBElt,vec)],    {list of (x,H) pairs}
 [(KGBElt,vec,Param,KParamPol)],     {corresonding mus}
 [( (KGBElt,vec),[(KGBElt,vec,Param,KParamPol)],[int],[int])]):   {[ ( bad_x_H_pair,mus,coeffs)]}
real_nilpotent_orbits(G,all_x_H_pairs(G),N)




set print_real_nilpotent_orbits(RealForm G,[(KGBElt,vec)] all_x_H_pairs,int N)=void:
prints("x  H  diagram   dimension");
let (orbits,mus,not_valid)=real_nilpotent_orbits(G,all_x_H_pairs,N) in
for O in orbits do prints(number(x(O)), " ", semisimple_element(O), " ", diagram(O),  "  ", dim_nilpotent(O)) od

set print_real_nilpotent_orbits(RealForm G, int N)=void:print_real_nilpotent_orbits(G,all_x_H_pairs(G),N)

set test(
([(KGBElt,vec)],
 [(KGBElt,vec,Param,KParamPol)],
 [((KGBElt,vec),[(KGBElt,vec,Param,KParamPol)],[int],[int])]) data)=
let (goodpairs,kparams,relations)=data in
let (x_0,)=goodpairs[0] then
G=real_form(x_0) in
for i:#relations do
let (pair,mus,coeffs,v)=relations[i] in
prints();prints("i=",i);
let (x,H)= pair
in
let ()=prints("(x,H): ", x, " ", H);
prints("mu(x,H): ", mu(x,H));
prints("smaller terms giving mu(x,H):") in
let rv=null_module(G) in
 let ()=for j:#mus do
 let (x,h,p,P)=mus[j] in
 rv+:=coeffs[j]*P;
 prints();prints("(x,h,p)=(",number(x),",",h,",",p,")");
 for c@p in P do prints(split_as_int(c), "*", p, " ", K_norm(p)) od;
prints(P) od in
prints();
prints("test relation (should equal mu(x,H)): ", rv);
prints(v)  od

