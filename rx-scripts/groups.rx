<basic.rx
<matrix

set show (string s) = if s="" then "empty" else s fi

set print_Cartan_info (CartanClass cc)=
let ((cr,Cr,sr),ww,(orbit_size,fiber_size),(i_tp,r_tp,C_tp))=Cartan_info(cc) in
begin
  prints("compact: ",cr,", complex: ",Cr,", split: ",sr)
; (let str="canonical twisted involution: " in
     if #ww=0 then str #:= "e"
     else str +:= ww[0]+1; for i : #ww-1 from 1 do str #:= ","+(ww[i]+1) od
     fi
   ; prints(str)
  )
; prints("twisted involution orbit size: ",orbit_size,
         "; fiber size: ",fiber_size,"; strong inv: ",orbit_size*fiber_size)
; prints("imaginary root system: ",show(str(i_tp)))
; prints("real root system: ",show(str(r_tp)))
; prints("complex factor: ",show(str(C_tp)))
end

{ Cartan matrix information for positions at distance d(<=2) off diagonal }
set Cartan_dispatch(int type, int r, int min, int d, bool lower)=
if d=0 then 2    { diagonal entry }
elif type=4 then { Dn }
 if if min<r-3 then d=1 else min=r-3 fi then -1 else 0 fi
elif type=5 then { En }
 if d=if min<2 then 2 else 1 fi then -1 else 0 fi
elif d=2 then 0  { nodes far apart in liear diagrams }
elif type<4 then { classical linear diagrams }
 if type = if lower then 2 else 3 fi and min=r-2 then -2 else -1 fi
elif type=6 then if lower and min=1 then -2 else -1 fi { F4 }
elif lower then -1 else -3 { G2 }
fi

set Cartan_entry(int type, int r,int i, int j)=
if type=0 then 0 { null Cartan entries for torus factors }
else let (min,d) = if i<j then (i,j-i) else (j,i-j) fi
     in  if d>2 then 0 else Cartan_dispatch(type,r,min,d,i<j) fi
fi

set Cartan_matrix(int type, int r)= mat:
for j:r do for i:r do Cartan_entry(type,r,i,j) od od

set Lie_type((int,int) p) =
  let (type,) = Cartan_matrix_type(Cartan_matrix(p)) in type

set block_repeat(mat m, int n) =
let (r,c)=#m then result = null(n*r,n*c)
in for k:n do for i:r do for j:c do
      result[k*r+i,k*c+j]:=m[i,j]
   od od od; result

{ complex group for |rd| (the group viewed as a real form of doubled type) }
set complex(RootDatum rd) = RealForm:
let r=rank(rd)
then C_inv=null(2*r,2*r)
, rd_C = root_datum(block_repeat(simple_roots(rd),2)
                   ,block_repeat(simple_coroots(rd),2)
                   ,2*r)
in (for i:r do C_inv[i,i+r]:=1; C_inv[i+r,i]:=1 od
   ; quasisplit_form(inner_class(rd_C,C_inv)))

{ complexification of a real group }
set complexification(RealForm G) = RealForm: complex(root_datum(G))

{ some root systems }

{ type A root data }

set GL_roots (int n) = [vec]:
for i : n-1
do for j : n
   do if j=i then 1 elif j=i+1 then -1 else 0 fi od
od

set SL_coroots (int n) = [vec]:
for i : n-1
do for j : n-1
   do if j=i then 1 elif j=i+1 then -1 else 0 fi od
od

set SL_roots (int n) = [vec]:
for col@j in SL_coroots(n)
do if j<n-2 then col
   else for e in col do e+1 od
   fi
od

set GL(int n)= let r=GL_roots(n) in root_datum(r,r,n)
set SL(int n)= root_datum(SL_roots(n),SL_coroots(n),n-1)
set PSL(int n)=root_datum(SL_coroots(n),SL_roots(n),n-1)

{ rotts and coroots in nice coordinates for roots in types B,C,D }

set type_B_roots (int n) = [vec]:
for i : n
do if i<n-1
   then for j : n
        do if j=i then 1 elif j=i+1 then -1 else 0 fi od
   else for j : n do if j<n-1 then 0 else 1 fi od
   fi
od

set type_C_roots (int n) = [vec]:
for i : n
do if i<n-1
   then for j : n
        do if j=i then 1 elif j=i+1 then -1 else 0 fi od
   else for j : n do if j<n-1 then 0 else 2 fi od
   fi
od

set type_D_roots (int n) = [vec]:
if n<2 then [] { SO(2) is pure torus }
else
  for i : n
  do if i<n-1
     then for j : n
          do if j=i then 1 elif j=i+1 then -1 else 0 fi od
     else for j : n do if j<n-2 then 0 else 1 fi od
     fi
  od
fi

{ type C root data }

set Sp(int n)=
let (m,r)=n\%2 in
( if r=1 then error("Odd symplectic datum") fi
; root_datum(type_C_roots(m),type_B_roots(m),m)
)

set PSp(int n)=
if n%2=1 then error("Odd symplectic datum") else
let type= if n\2=1 then "A" else "C" fi in adjoint(type+int_format(n\2)) fi

set GSp(int n)=
if n%2=1 then error("Odd symplectic datum") else
let type= if n\2=1 then "A1.T1" else "C"+int_format(n\2)+"T1" fi in
root_datum(Lie_type(type),quotient_basis(Lie_type(type),[[1/2,1/2]]))
fi

{ type B/D root data }

{ use the standard basis for SO(n) }
set SO(int n)=
let m=n\2 in
if n%2=1
then root_datum(type_B_roots(m),type_C_roots(m),m)
else let r=type_D_roots(m) in root_datum(r,r,m)
fi

set SO_lie_type(int n)=
if n=1 then "" elif
n=2 then "T1" elif
n=3 then "A1" elif
n=4 then "A1.A1" elif
n=6 then "A3" elif
n%2=1 then "B"+n\2 else
"D"+n\2 fi

set Spin(int n)=simply_connected(SO_lie_type(n))
set PSO(int n)=adjoint(SO_lie_type(n))


{ type A real forms }

{ here rd should be SL(p+q) or PSL(p+q) }
set SU(int p,int q, RootDatum rd)=
let n=p+q
then ic = inner_class(rd,if n>1 then "c" else "" fi)
in real_form(ic,min(p,q))

set SU(int p,int q)=SU(p,q,SL(p+q))
set PSU(int p,int q)=SU(p,q,PSL(p+q))
set SU(int n) = SU(n,0)
set PSU(int n) = PSU(n,0)

{ U(p,q), no isogenies in this case }
set U(int p,int q)=
real_form(inner_class(GL(p+q),if p+q>1 then "cc" else "c" fi),min(p,q))

set SL_R(int n) = quasisplit_form(inner_class(SL(n),if n>1 then "s" else "" fi))
set PSL_R(int n)=
  quasisplit_form(inner_class(PSL(n),if n>1 then "s" else "" fi))
set PGL_R(int n)=PSL_R(n)

set SL_C(int n) = complex(SL(n))
set PSL_C(int n) = complex(PSL(n))
set PGL_C(int n) = PSL_C(n)

set SL_H(int n) = real_form(inner_class(SL(2*n),"s"),0)
set PSL_H(int n) = real_form(inner_class(PSL(2*n),"s"),0)
set PGL_H(int n) = PSL_H(n)

set GL_R(int n) =
  quasisplit_form(inner_class(GL(n),if n>1 then "ss" else "s" fi))
set GL_C(int n) = complex(GL(n))
set GL_H(int n) = RealForm: error("gl(n,H) is not yet implemented")

{complex and quaternionic groups of type A}

{ to allow alternate syntax: for instance Sp(4,R) instead of Sp_R(4) }
set (R,C,H)=("R","C","H")

set by_field((int->RealForm) f_R,(int->RealForm) f_C,(int->RealForm) f_H) =
(string K): if K=R then f_R elif K=C then f_C elif K=H then f_H
                   else error("unknown field "+K)
                   fi

set SL(int n, string K) = by_field (SL_R@int,SL_C@int,SL_H@int) (K)(n)
set GL(int n, string K) = by_field (GL_R@int,GL_C@int,GL_H@int) (K)(n)
set PSL(int n, string K) = by_field (PSL_R@int,PSL_C@int,PSL_H@int) (K)(n)
set PGL(int n, string K) = PSL(n,K)

{ type C real forms }

{ split real forms }
{calls to Sp(n), PSp(n), GSp(n) catch odd n}
set Sp_R(int n)=quasisplit_form(inner_class(Sp(n),"e"))
set PSp_R(int n)=quasisplit_form(inner_class(PSp(n),"s"))
set GSp_R(int n)=quasisplit_form(inner_class(GSp(n),"ss"))

{ Sp(p,q) }

set Sp(int p,int q)=real_form(inner_class(Sp(2*(p+q)),"e"),min(p,q))
set PSp(int p,int q)=real_form(inner_class(PSp(2*(p+q)),"e"),min(p,q))

{ complex and quaternionic real forms }

set Sp_C(int n) = complex(Sp(n)) { |Sp| will test |n| even }
set Sp_H(int n) = RealForm: error("Sp(n,H) is not yet implemented")

set PSp_C(int n) = complex(PSp(n)) { |Sp| will test |n| even }
set PSp_H(int n) = RealForm: error("PSp(n,H) is not yet implemented")

set GSp_C(int n) = complex(GSp(n)) { |Sp| will test |n| even }
set GSp_H(int n) = RealForm: error("PSp(n,H) is not yet implemented")

set Sp(int n, string K) = by_field (Sp_R@int,Sp_C@int,Sp_H@int) (K)(n)
set PSp(int n, string K) = by_field (PSp_R@int,PSp_C@int,PSp_H@int) (K)(n)
set GSp(int n, string K) = by_field (GSp_R@int,GSp_C@int,GSp_H@int) (K)(n)

{ type B/D real forms }

set SO_inner_class(int p,int q)=
let ic=
 if p+q=1 then ""
elif p+q=4 then if p%2=0 then "ee" else "C" fi
else
 if p%2=1 and q%2=1 then
  if (p+q)%4=0 and p+q>4 then "u" else "s" fi
else "e" fi fi in ic

set SO_real_form_number(int p,int q)=
let n=p+q, (p,q) = if p<q then (q,p) else (p,q) fi { make q the smallest one }
then number =
      if n<=2 then 0        { inner classes without noncompact form, SO(2)=T1 }
      elif n%2=1 then q     { type B_{n\2} }
      elif q%2=1 then q\2   { type D_{n\2}, unequal rank }
      elif q<=n\4 then q\2  { type D_{n\2}, equal rank, more compact forms }
      elif n%4=2 then q\2+1 { type D_{n\2}odd, equal rank, more split forms }
      else q\2+2            { type D_{n\2}even, equal rank, more split forms }
      fi
in number

set SO(int p,int q,RootDatum rd) =
  real_form(inner_class(rd,SO_inner_class(p,q)),SO_real_form_number(p,q))

set Spin(int p,int q)=SO(p,q,Spin(p+q))
set SO(int p,int q)=SO(p,q,SO(p+q))
set PSO(int p,int q)=SO(p,q,PSO(p+q))

{ exceptional groups }

set E6_ic_e = inner_class (simply_connected ("E6"),"e")

set E6_c = real_form(E6_ic_e,0)
set E6_h = real_form(E6_ic_e,1)
set E6_D5T = real_form(E6_ic_e,1)
set E6_q = real_form(E6_ic_e,2)

set E6_ic_s = inner_class (simply_connected ("E6"),"s")

set E6_F4 = real_form(E6_ic_s,0)
set E6_s = real_form(E6_ic_s,1)
set E6_C4 = real_form(E6_ic_s,1)

set E7_ic_e = inner_class (simply_connected ("E7"),"e")

set E7_ic = inner_class (simply_connected ("E7"),"e")
set E7_c = real_form(E7_ic_e,0)
set E7_h = real_form(E7_ic_e,1)
set E7_E6T = real_form(E7_ic_e,1)
set E7_q = real_form(E7_ic_e,2)
set E7_D6A1 = real_form(E7_ic_e,2)
set E7_s = real_form(E7_ic_e,3)
set E7_A7 = real_form(E7_ic_e,3)

set E8_ic = let ic=inner_class("T0",[],""), first=true in ():
  if first then ic:=inner_class(simply_connected("E8"),"e") next first:=false
  else ic
  fi

set E8_c() = real_form(E8_ic(),0)
set E8_q() = real_form(E8_ic(),1)
set E8_s() = real_form(E8_ic(),2)
