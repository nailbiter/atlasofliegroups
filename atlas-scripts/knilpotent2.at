<knilpotent.at
<K_types.at

set smash([int] v,[[int]] A)=[[int]]:
let rv=[] in
for a in A do
 for c in v do rv#:=c#a od od;rv

set rec_fun box(int height, int rank)=[[int]]:
if rank=1 then for i:height do [i] od else
smash(for i:height do i od,box(height,rank-1)) fi

set rec_fun box([int] heights)=[[int]]:
if #heights=1 then for i:heights[0] do [i] od else
smash(for i:heights[0]  do i od,box(delete(heights,0))) fi

set all_lambda(RealForm G,int height)=
let x=KGB(G,KGB_size(G)-1) then
theta=involution(x) then
M=1-theta then
(A,v)=adapted_basis(M) then
()=for i:n_columns(A)-#v do v#:=height od then
box=box(v) then
rho=rho(G) in
for w in box do A*(rho+w) od

set many_minimal_ps(RealForm G,int height)=[Param]:
let x=KGB(G,KGB_size(G)-1) then
lambdas=all_lambda(G,height) then
nu=rho(G) in
let P=[Param]:[] in
for lambda in lambdas do
let p=parameter(x,lambda,nu) in
if is_standard(p) and not is_zero(p) then P#:=monomials(ParamPol:p) fi od;P
