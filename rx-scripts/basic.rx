set # (int n)= [int]: for i:n do i od       { [0,1,...,n-1] }
set # (bool b) = int: if b then 1 else 0 fi { Iverson symbol }
set # (ratvec v)= int: let (n,)=%v in #n    { length }

set ^ = !=@(bool,bool) { exclusive or }

set assert (bool b,string message) = void: if not b then error(message) fi
set assert (bool b) = void: assert(b,"assertion failed") { default message }

{ bitsets encoded as functions (int->bool) and upper bound limit }

set list ((int->bool) filter, int limit) = [int]:
  let result=[int]:[]
  in for i:limit do if filter(i) then result#:=i fi od; result
set complement ((int->bool) filter, int limit) = [int]:
  let result=[int]:[]
  in for i:limit do if not filter(i) then result#:=i fi od; result

set count ((int->bool) filter, int limit) = int:
  let c=0 in for i:limit do if filter(i) then c+:=1 fi od; c

set all ([bool] p) = bool:
  let i=#p-1 in while >=i and p[i] do i-:=1 od; <i
set none ([bool] p) = bool:
  let i=#p-1 in while >=i and not p[i] do i-:=1 od; <i
set first ([bool] p) = int:
  let i=0,n=#p in while i<n and not p[i] do i+:=1 od; if i=n then -1 else i fi
set last ([bool] p) = int: { this is somewhat more efficient than first }
  let i=#p-1 in while >=i and not p[i] do i-:=1 od; i

set all (int limit,(int->bool) filter) = bool:
  while limit-:=1; >=limit and filter(limit) do () od; <limit
set none (int limit,(int->bool) filter) = bool:
  while limit-:=1; >=limit and not filter(limit) do () od; <limit
set first (int limit,(int->bool) filter) = int:
  let i=0
  in while i<limit and not filter(i) do i+:=1 od; if i=limit then -1 else i fi
set last (int limit,(int->bool) filter) = int:
  while limit-:=1; >=limit and not filter(limit) do () od; limit



{				Integers				}

set abs (int k)= int: if <k then -k else k fi
set sign (int k)= int: if >k then 1 elif <k then -1 else 0 fi

set is_odd  (int n) = bool: n%2=1
set is_even (int n) = bool: n%2=0

set min (int k, int l) = int: if k<l then k else l fi
set max (int k, int l) = int: if k<l then l else k fi

set =  ((int,int)(x0,y0),(int,int)(x1,y1)) = bool: x0=x1 and y0=y1
set != ((int,int)(x0,y0),(int,int)(x1,y1)) = bool: x0!=x1 or y0!=y1



{			    Rational numbers				}

set numer (rat a) = let (n,)=%a in n
set denom (rat a) = let (,d)=%a in d

set is_integer (rat r) = bool: denom(r)=1
set sign (rat a)= int: sign(numer(a)) { denominator is always positive }

set floor (rat a) = int: \ %a     { decompose, then integer division }
set ceil  (rat a) = int: -\ %-a   { same, sandwiched in negations }

set \ ((rat,int)p) = int: floor(/p)
set \ ((rat,rat)p) = int: floor(/p)

{ these are mostly for ratvec arguments, but [rat] refuses coercion from vec }
set floor ([rat] v) = vec: for a in v do floor(a) od
set ceil  ([rat] v) = vec: for a in v do  ceil(a) od


{ make a rational into an integer if possible }
set rat_as_int (rat r) = int:
  let (n,d)=%r in if d=1 then n else error("Not an integer") fi



{				Strings					}

set !new_line = ascii(10) { including this in a string passes to a new line }

set + (string s,string t) = string: s # t { alias for concatenation }
set * = (string,int->string): { repeat string; use recursive doubling }
  let rep(string s,int n) = string: s in
  begin rep:=((string s,int n) string:
      if n=1 then s
      else let (q,r)=n\%2 then half=rep(s,q) in
        half # if =r then half else half#s fi
      fi)
  ; (string s,int n) string: if <=n then "" else rep(s,n) fi
  end

set + (string s, int i)= string: s # int_format(i)
set + (int i, string s)= string: int_format(i) # s

set + (string s, (int,int)(x,y)) = s + "(" + x + "," + y + ")"



{				Vectors					}

set vector (int n,(int->int)f) = vec: for i:n do f(i) od

set ones (int n)= vec: for i:n do 1 od

{ for computing greatest common divisors, inv_fact can do most of the work }
set gcd ([int] v)= int:
  let f=inv_fact(stack_rows([v])) in if =#f then 0 else f[0] fi

{ scalar multiplication; is built-in for the preferred order vec*int }
set * (int c,vec v) = vec: v*c

{ sum, product of entries }
set sum (vec v)= (let one=1 in for x in v do one od) * v
set product (vec v)= let s=1 in for e in v do s*:=e od; s

set reverse (vec v)= vec: v~[:]
set lower (int k,vec v)= vec: v[:k]
set upper (int k,vec v)= vec: v[k~:]
set drop_lower (int k,vec v)= vec: v[k:]
set drop_upper (int k,vec v)= vec: v[:k~]

set <= (vec v) = bool: >= -v { anti-dominance (in fundamental weight coords) }
set <  (vec v) = bool: > -v  { strict anti-dominance }

set is_member ([int] v) = (int->bool):
  let start = #v-1 { pre-computation might be more efficient }
  in (int val)bool: let i=start in while >=i and v[i]!=val do i-:=1 od; >=i

set contains (int val) = ([int]->bool): ([int] v)bool: is_member(v)(val)



{				Matrices				}

{ matrix defined by its dimension and expression for general entry }
set matrix ((int,int)(r,c),(int,int->int) f) = mat:
  r#for j:c do for i:r do f(i,j) od od

set n_rows (mat m)= int: let (r,)=#m in r
set n_columns (mat m)= int: let (,c)=#m in c

set column (vec v) = mat: [v] { interpret v as single column }
set row (vec v)    = mat: ^v  { interpret v as single row }

{ test matrix against a multiple of the identity }
set = (mat m,int k) = bool: =(m-k)

{ add a column to a matrix, which is not predefined as operator # }
set # (mat m, vec v) = mat: n_rows(m) { require size match } # (([vec]:m)#v)
set # (vec v, mat m) = mat: n_rows(m) { require size match } # (v#([vec]:m))

{ add row to a matrix, which is similar; use operator ^ for it }
set ^ (mat m, vec v) = mat: n_columns(m) ^ (([vec]:^m)#v)
set ^ (vec v, mat m) = mat: n_columns(m) ^ (v#([vec]:^m))

set # (mat A, mat B) = mat: { concatenate horizontally, must have same depth }
   n_rows(B)#(([vec]:A)#([vec]:B))
set ^ (mat A, mat B) = mat: { concatenate vertically, must have same width }
   n_columns(B) ^ (([vec]:^A)#([vec]:^B))

{ test all columns }
set all (mat M,(vec->bool) filter) = bool:
  let j=n_columns(M)-1 in while >=j and filter(M[j]) do j-:=1 od; <j
set none (mat M,(vec->bool) filter) = bool:
  let j=n_columns(M)-1 in while >=j and not filter(M[j]) do j-:=1 od; <j
set first (mat M,(vec->bool) filter) = int:
  let j=0, n=n_columns(M)
  in while j<n and filter(M[j]) do j+:=1 od; if j=n then -1 else j fi
set last (mat M,(vec->bool) filter) = int:
  let j=n_columns(M)-1 in while >=j and filter(M[j]) do j-:=1 od; j

{ apply a function to all matrix entries }
set map_on (mat m) = ((int->int)->mat):
  let nr = n_rows(m)
  in ((int->int)f) mat: nr # for c in m do for e in c do f(e) od od

{ scalar multiplication }
set * (int c,mat m) = mat: map_on(m)((int e) int: c*e)
set - (mat m)= mat: { transform 36+128=164: 128 means negate entries }
  swiss_matrix_knife(164,m,0,0,0,0)

{ integer division }
set \ (mat m,int d) = mat: map_on(m)((int e) int: e\d)

{ entrywise modulo }
set % (mat m,int d) = mat: map_on(m)((int e) int: e%d)

{ matrix exponentiation }
set ^ =
  let matrix_power (mat m,int n)= mat: m { dummy for recursion } in
  begin matrix_power := { assign recursive function body }
    ( (mat m,int n): { we shall have n>0 }
      if n=1 then m
      else let (q,r)=n\%2 then mm=matrix_power(m,q) in
	mm*if =r then mm else mm*m fi
      fi
    )
  ; (mat m,int n) mat: { the actual operator ^ :}
      assert(=#m,"Non square matrix in exponentiation")
    ; if n>0 then matrix_power(m,n) elif =n then id_mat(n_rows(m))
      else let (m1,d)=invert(m) in
        if d=1 then matrix_power(m1,-n)
        elif =d then error("Negative power of singular matrix")
        else error("Negative power of matrix not invertible over Z")
        fi
      fi
  end

set inverse (mat M) = mat:
  let (inv,d)=invert(M) in
  if d=1 then inv else error("Matrix not invertible over the integers") fi

set det (mat M) = int:
( let (diag,,)=diagonalize(M), (n,):shape = #M in
  assert(=shape,"Determinant of non-square matrix")
; if #diag<n then 0 { there is at least one zero on the diagonal }
  else product(diag) { otherwise multiply out }
  fi
)

set columns_with ((int,vec->bool) p,mat m) = mat:
  let res = [vec]: [] in
  for col@j in m do if p(j,col) then res #:= col fi od; n_rows(m)#res
set columns_with ((vec->bool) p,mat m) = mat:
  columns_with (((int,vec)(,col))bool: p(col),m)
set columns_with ((int->bool) p,mat m) = mat:
  columns_with (((int,vec)(j,))bool: p(j),m)

set rows_with ((int,vec->bool) p,mat m) = mat:
  let res = [vec]: [] in
  for row@i in ^m do if p(i,row) then res #:= row fi od; n_columns(m)^res
set rows_with ((vec->bool) p,mat m) = mat:
  rows_with (((int,vec)(,row))bool: p(row),m)
set rows_with ((int->bool) p,mat m) = mat:
  rows_with (((int,vec)(i,))bool: p(i),m)

set >=(mat m) = bool: { test for having non-negative entries only }
  let j=n_columns(m)-1 in while >=j and >=m[j] do j-:=1 od; <j
set >(mat m) = bool: { all columns are strictly positive }
  let j=n_columns(m)-1 in while >=j and >m[j] do j-:=1 od; <j
set <=(mat m) = bool: >= -m
set <(mat m) = bool: > -m

set lookup_column (vec v,mat m) = int:
  let i=n_columns(m)-1 in while >=i and m[i]!=v do i-:=1 od; i
set lookup_row (vec v,mat m) = int:
  lookup_column(v,^m)

{ sum of columns of a matrix; this is so neat, avoid calling it sum_columns }
set sum (mat m)= vec: m*ones(n_columns(m))

{ order of a matrix, hangs unless finite }
set order (mat !M) = int:
  let (n,):p =#M in assert(=p,"Matrix is not square");
  let N=M, order=1, I=id_mat(n) in
  while N!=I do N *:= M; order+:=1 od; order



{			    Rational vectors				}

set numer (ratvec a) = vec: let (n,)=%a in n
set denom (ratvec a) = int: let (,d)=%a in d

{ allow scalar multiplication form left; from right it is built-in }
set * (int i,ratvec v) = ratvec: v*i
set * (rat r,ratvec v) = ratvec: v*r

{ concatenate ratvec values: use conversion to and from [rat] }
set #(ratvec a,ratvec b) = ratvec: #([rat]:a,[rat]:b)

{ multiply rational matrix represented as list of columns by a rational vector
  the m*n matrix M is given as a list of n ratvec values of size m
  v is a ratvec of size n, the result is a ratvec of size m
}
set * ([ratvec] M,ratvec v) = ratvec:
  let m=#M { number of columns } in
  assert(!=m { cannot handle empty matrix } and m=#v,"size mismatch");
  let result = null(#M[0])/1 in for col@j in M do result +:= col*v[j] od;
  result

set is_integer (ratvec v) = bool: let (,d)=%v in d=1 { equivalently =(v%1) }

{ extend built-in scalar product of vectors to rational vector case }
set * (ratvec v, ratvec w) = rat: let (nv,dv)=%v,(nw,dw)=%w in nv*nw/(dv*dw)

set * (vec v, ratvec w) = rat: let (nw,dw)=%w in v*nw/dw { more efficient }
{ one cannot also define: *(ratvec v, vec w) = rat: let (nv,dv)=%v in nv*w/dv }

{ vector floor of quotient operation, makes vector from rational vector }
set \ (ratvec v, int k) = vec: let (n,d)=%v in n\(k*d)

{ do as |v\1| (or |\ %v|) would do, but protest if there would be a remainder }
set ratvec_as_vec (ratvec v) = vec:
  let (w,d)=%v in assert(d=1,"Not an integer vector"); w

set reverse (ratvec v)= ratvec: v~[:]
set lower (int k,ratvec v)= ratvec: v[:k]
set upper (int k,ratvec v)= ratvec: v[k~:]
set drop_lower (int k,ratvec v)= ratvec: v[k:]
set drop_upper (int k,ratvec v)= ratvec: v[:k~]

set <= (ratvec v) = bool: <=numer(v)
set <  (ratvec v) = bool: < numer(v)



{			    Split integers				}

set !s = Split:(0,1) { ! means it is a constant }

set int_part (Split x) = int: let (r,)=%x in r
set s_part (Split x) = int: let (,y)=%x in y { s part }
{ the names of the synonym operators are mysterious, but maybe it is convenient }
set + = int_part@Split
set ^ =   s_part@Split

set s_to_1 (Split x) = int: +%x        { let (a,b)=%x in +(a,b) }
set s_to_minus_1 (Split x) = int: -%x  { let (a,b)=%x in -(a,b) }

set split_as_int (Split x) = int:
  let (r,y)=%x in assert(=y,"split is not an integer"); r

{ nicer display of Splits }
set split_format (Split w) = string:
  let (a,b)=%w in
  if =a and !=b
  then if abs(b)>1 then int_format(b) elif b=1 then "" else "-" fi #"s"
  else int_format(a) #
    if abs(b)>1 then if <b then "" else "+" fi #int_format(b)#"s"
    elif =b then "" elif b=1 then "+s" else "-s"
    fi
  fi

set ^ = { exponentiation of split integers }
  let split_power (Split x,int n) = Split: x { dummy }
  then () = split_power := ((Split x,int n): { we shall have n>0 }
    if n=1 then x
    else let (q,r)=n\%2 then y=split_power(x,q) in y*if =r then y else x*y fi
    fi)
  in { set ^ = } (Split x,int n): Split:
    if n>0 then split_power(x,n) elif =n then Split:(1,0)
    elif let (a,b)=%x in abs(a)+abs(b)=1 { cases of invertible (unit) Split }
    then if is_even(n) then 1 else x fi { all of which are square roots of +1 }
    else error("Negative power "+n+" of split integer "+split_format(x))
    fi


{				Root data 				}

{ backwards compatibility function; used to be the built-in prototype }
set root_datum ([vec] simple_roots, [vec] simple_coroots, int r) = RootDatum:
  root_datum(r#simple_roots,r#simple_coroots)

set root_datum (LieType t, [ratvec] gens) = RootDatum:
  root_datum(t,quotient_basis(t,gens))

{ allow single kernel generator in root datum construction }
set root_datum (LieType t, ratvec gen) = RootDatum: root_datum(t,[gen])

{ the following uses that root_index(rd,v)=nr_of_posroots(rd) for a non-root v }
set is_root ((RootDatum,vec) (rd,):p) = bool:
  root_index(p)<nr_of_posroots(rd)
set is_coroot ((RootDatum,vec) (rd,):p) = bool:
  coroot_index(p)<nr_of_posroots(rd)
set is_posroot ((RootDatum,vec)(rd,):p) = bool:
  let ri=root_index(p) in >=ri and ri<nr_of_posroots(rd)
set is_coposroot ((RootDatum,vec)(rd,):p) = bool:
  let cri=coroot_index(p) in >=cri and cri<nr_of_posroots(rd)

set posroot_index ((RootDatum,vec)p) = int: { fold roots to positive }
  let i=root_index(p) in if <i then -1-i else i fi
set poscoroot_index ((RootDatum,vec)p) = int: { fold coroots to positive }
  let i=coroot_index(p) in if <i then -1-i else i fi


set rho (RootDatum rd) = ratvec:
  let res= ratvec: null(rank(rd))
  in for i:semisimple_rank(rd) do res +:= fundamental_weight(rd,i) od; res
{ this uses fewer additions than computing half sum of the positive roots }

{ make rho as a vector of integers if possible }
set rho_as_vec (RootDatum r)= vec: ratvec_as_vec(rho(r))

set rho_check (RootDatum rd) = ratvec: { rho(dual(rd)), but a bit faster }
  let res= ratvec: null(rank(rd))
  in for i:semisimple_rank(rd) do res +:= fundamental_coweight(rd,i) od; res

{ see also rho_i@KGBElt and rho_r@KGBElt defined below }

set is_positive_root (RootDatum rd) = (vec->bool):
  let rc = rho_check(rd) in (vec alpha) bool: rc*alpha>0
set is_positive_coroot (RootDatum rd) = (vec->bool):
  let rho = rho(rd) in (vec alphav) bool: alphav*rho>0
set is_negative_root (RootDatum rd) = (vec->bool):
  let rc = rho_check(rd) in (vec alpha) bool: rc*alpha<0
set is_negative_coroot (RootDatum rd) = (vec->bool):
  let rho = rho(rd) in (vec alphav) bool: alphav*rho<0

set is_positive_root (RootDatum rd,vec alpha) = bool:
  is_positive_root(rd)(alpha)
set is_positive_coroot (RootDatum rd,vec alphav) = bool:
  is_positive_coroot(rd)(alphav)
set is_negative_root (RootDatum rd,vec alpha) = bool:
  is_negative_root(rd)(alpha)
set is_negative_coroot (RootDatum rd,vec alphav) = bool:
  is_negative_coroot(rd)(alphav)

set negative_system (mat posroots) = { the missing half of the root system }
  swiss_matrix_knife(172,posroots,0,0,0,0) { 172= 36+8+128: reverse cols,neg }

{ having _all_ roots can be useful }
set roots (RootDatum rd) = mat:
  let pr=posroots(rd) in negative_system(pr)#pr
set coroots (RootDatum rd) = mat:
  let pcr=poscoroots(rd) in negative_system(pcr)#pcr

{ the correspondence between roots and coroots }
set root (RootDatum rd, vec alpha_v) = vec: root(rd,coroot_index(rd,alpha_v))
set coroot (RootDatum rd, vec alpha) = vec: coroot(rd,root_index(rd,alpha))

{ reflection action of roots }
set reflection (RootDatum rd, int i) = mat: { i indexes a root/coroot pair }
  1 - column(root(rd,i))*row(coroot(rd,i))
set reflection ((RootDatum,vec)(rd,):p) = mat: { specify root (not coroot) }
  reflection(rd,root_index(p))
set coreflection (RootDatum rd, int i) = mat: { i indexes a root/coroot pair }
  1 - column(coroot(rd,i))*row(root(rd,i))
set coreflection ((RootDatum,vec)(rd,):p) = mat: { specify root (not coroot) }
  coreflection(rd,root_index(p))
set reflect (RootDatum rd, int i, vec v) = vec: { apply reflection(rd,i)*v }
  v -:= root(rd,i) * (coroot(rd,i)*v) { more efficient than matrix multiply }
set reflect (RootDatum rd, vec alpha, vec v) = vec: { reflection(rd,alpha)*v }
  v -:= alpha * (coroot(rd,alpha)*v)
set coreflect (RootDatum rd, vec v, int i) = vec: { apply v*reflection(rd,i) }
  v -:= (v*root(rd,i)) * coroot(rd,i)
set coreflect (RootDatum rd, vec v, vec alpha) = vec: { v*reflection(rd,alpha) }
  v -:= (v*alpha) * coroot(rd,alpha)

set reflect (RootDatum rd, int i, ratvec v) = ratvec:
  let (n,d) = %v in reflect(rd,i,n)/d
set reflect (RootDatum rd, vec alpha, ratvec v) = ratvec:
  let (n,d) = %v in reflect(rd,alpha,n)/d
set coreflect (RootDatum rd, ratvec v, int i) = ratvec:
  let (n,d) = %v in coreflect(rd,n,i)/d
set coreflect (RootDatum rd, ratvec v, vec alpha) = ratvec:
  let (n,d) = %v in coreflect(rd,n,alpha)/d

{ in matrix version reflect becomes left_reflect and coreflect right_reflect }
set left_reflect (RootDatum rd, int i, mat M) = mat: { reflection(rd,i)*M }
  n_rows(M) # for v in M do reflect(rd,i,v) od
set left_reflect (RootDatum rd, vec alpha, mat M) = mat:
  left_reflect(rd,root_index(rd,alpha),M)
set right_reflect (RootDatum rd, mat M, int i) = mat: { M*reflection(rd,i) }
  n_columns(M) ^ for row in ^M do coreflect(rd,row,i) od
set right_reflect (RootDatum rd, mat M, vec alpha) = mat:
  right_reflect(rd,M,root_index(rd,alpha))

set conjugate (RootDatum rd, int i, mat M) = mat: { r*M*r where r=reflection }
  left_reflect(rd,i,right_reflect(rd,M,i))
set conjugate (RootDatum rd, vec alpha, mat M) = mat:
  conjugate(rd,root_index(rd,alpha),M)


set singular_simple_indices (RootDatum rd,ratvec v) = [int]:
  let rv=[int]:[] { cannot use columns_with: must find _indices_ of columns }
  in for a@j in simple_coroots(rd) do if =a*v then rv:=rv#j fi od; rv

set is_imaginary (mat theta) = (vec->bool): (vec alpha): theta*alpha=alpha
set is_real      (mat theta) = (vec->bool): (vec alpha): theta*alpha=-alpha
set is_complex   (mat theta) = (vec->bool): (vec alpha):
  let ta = theta*alpha in ta!=alpha and ta!=-alpha

{ these functions are just for convenience; posroot versions are more useful }
set imaginary_roots (RootDatum rd, mat theta) = mat:
  columns_with(is_imaginary(theta),roots(rd))
set real_roots (RootDatum rd, mat theta) = mat:
  columns_with(is_real(theta),roots(rd))

{ for coroots we need to use the transpose matrix }
set imaginary_coroots (RootDatum rd, mat theta) = mat:
  columns_with(is_imaginary(^theta),coroots(rd))
set real_coroots (RootDatum rd, mat theta) = mat:
  columns_with(is_real(^theta),coroots(rd))

{ positive (co)roots versions are actually more useful }
set imaginary_posroots (RootDatum rd,mat theta) = mat:
  columns_with(is_imaginary(theta),posroots(rd))
set real_posroots (RootDatum rd,mat theta) = mat:
  columns_with(is_real(theta),posroots(rd))
set imaginary_poscoroots (RootDatum rd,mat theta) = mat:
  columns_with(is_imaginary(^theta),poscoroots(rd))
set real_poscoroots (RootDatum rd,mat theta) = mat:
  columns_with(is_real(^theta),poscoroots(rd))
set imaginary_sys ((RootDatum,mat)p) = (mat,mat):
  (imaginary_posroots(p),imaginary_poscoroots(p))
set real_sys ((RootDatum,mat)p) = (mat,mat):
  (real_posroots(p),real_poscoroots(p))

{ returns whether v is a weakly dominant weight for rd }
set is_dominant (RootDatum rd, ratvec v) = bool:
  >=(numer(v)*simple_coroots(rd))
set is_strictly_dominant (RootDatum rd, ratvec v) = bool:
  >(numer(v)*simple_coroots(rd))
set is_regular (RootDatum rd,ratvec v)= bool: { tests all positive coroots }
  all(for x in numer(v)*poscoroots(rd) do !=x od)
set is_integral (RootDatum rd, ratvec v) = bool: { integral on all coroots }
  =(v*simple_coroots(rd)%1)


{ the following functions give but partial information; giving a more complete
  definition for InnerClass values needs more work (see group_operations.rx)
}
set derived (RootDatum rd) = RootDatum: let (d,)=derived_info(rd) in d
set mod_central_torus (RootDatum rd) = RootDatum:
  let (d,)=mod_central_torus_info(rd) in d
set adjoint (RootDatum rd) = RootDatum: { change weight basis to simple roots }
  root_datum(id_mat(semisimple_rank(rd)),Cartan_matrix(rd))

{ from appropriate (subsystem) dual 2rho value, deduce test for being simple }
set is_simple_for (vec dual_two_rho) = (vec->bool):
  (vec alpha): dual_two_rho*alpha=2

{ get generating simple system from set of matching posroots and poscoroots }
set simple_from_positive (mat posroots,mat poscoroots) = (mat,mat):
  ( columns_with(is_simple_for(sum(poscoroots)),posroots)
  , columns_with(is_simple_for(sum(posroots)),poscoroots)
  )

set fundamental_weights (RootDatum rd) = [ratvec]:
  for i:semisimple_rank(rd) do fundamental_weight(rd,i) od



{				Inner classes				}

set != (InnerClass x,InnerClass y) = bool: not(x=y)

{ integrality inner class (dual side) defined by inf. character and involution }
set dual_integral (InnerClass ic, ratvec gamma) = InnerClass:
  inner_class(dual(integrality_datum(ic,gamma)),-^distinguished_involution(ic))


{				Cartan classes				}

set Cartan_classes (InnerClass ic) = [CartanClass]:
  for i:nr_of_Cartan_classes(ic) do Cartan_class(ic,i) od

set print_Cartan_info (CartanClass cc) = void:
  let show (string s) = string: if s="" then "empty" else s fi
  , ((cr,Cr,sr),ww,(orbit_size,fiber_size),(i_tp,r_tp,C_tp)) = Cartan_info(cc)
  in
  begin
    prints("compact: ",cr,", complex: ",Cr,", split: ",sr)
  ; (let str = "canonical twisted involution: " in
       if =#ww then str #:= "e"
       else for s@i in ww do if =i then str +:= s+1 else str #:= ","+(s+1) fi od
       fi
     ; prints(str)
    )
  ; prints("twisted involution orbit size: ",orbit_size,
	   "; fiber size: ",fiber_size,"; strong inv: ",orbit_size*fiber_size)
  ; prints("imaginary root system: ",show(str(i_tp)))
  ; prints("real root system: ",show(str(r_tp)))
  ; prints("complex factor: ",show(str(C_tp)))
  end


set fundamental_Cartan (InnerClass ic) = CartanClass: Cartan_class(ic,0)
set fundamental_Cartan (RealForm f) = CartanClass:
  fundamental_Cartan(inner_class(f)) { this is constant on the inner class }
set most_split_Cartan (InnerClass ic) = CartanClass:
  Cartan_class(ic,nr_of_Cartan_classes(ic)-1)
{ also most_split_Cartan@RealForm is built-in, but is not that of inner class }

set split_rank (CartanClass cc) = int:
  let ((,C,s),,,) = Cartan_info(cc) in C+s
set compact_rank (CartanClass cc) = int:
  let ((c,C,),,,) = Cartan_info(cc) in c+C


{				Real forms				}

set != (RealForm f, RealForm g) = bool: not(f=g)

set form_name (RealForm f) = string: form_names(f)[form_number(f)]

set real_forms (InnerClass ic)= [RealForm]:
  real_forms(fundamental_Cartan(ic))
set dual_real_forms (InnerClass ic) = [RealForm]:
  dual_real_forms(most_split_Cartan(ic))

set split_form (RootDatum r) = quasisplit_form(inner_class(r,-id_mat(rank(r))))

{ split form of a Lie type is taken simply connected (times a split torus) }
set split_form (LieType t) = split_form(simply_connected(t))

set quasicompact_form (InnerClass ic) = RealForm: real_forms(ic)[0]
{ quasisplit_form is built-in }

set is_compatible (RealForm f, RealForm g) = bool:
  let ic = inner_class(f)
  then oc = occurrence_matrix(ic)*^dual_occurrence_matrix(ic)
  in inner_class(g)=dual(ic) and oc[form_number(f),form_number(g)]>0

set is_compact (RealForm G) = bool: { real form 0 in equal rank inner class }
  KGB_size(G)=1 and distinguished_involution(G)=1



{			       KGB elements				}

set != (KGBElt x,KGBElt y) = bool: not(x=y)
set real_form (KGBElt x) = let (rf,) = %x in rf
set # (KGBElt x) = let (,n) = %x in n
set root_datum (KGBElt x) = RootDatum: real_form(x)
set inner_class (KGBElt x) = InnerClass: real_form(x)

set KGB (RealForm rf) = [KGBElt]: for i:KGB_size(rf) do KGB(rf,i) od

set KGB_elt ((InnerClass, mat, ratvec) (,theta,v):all) = KGBElt:
  let rf = real_form(all)   { find real form within ic }
  in KGB_elt(rf,theta,v)    { find KGB element within rf }

{ NB: elements produced by the following function test unequal to any others }
set KGB_elt (RootDatum rd, mat theta, ratvec v) = KGBElt:
  let ic = inner_class(rd,theta)   { find the proper inner class }
  then rf = real_form(ic,theta,v)  { find real form within ic }
  in KGB_elt(rf,theta,v)           { find KGB element within rf }

set Cartan_class (InnerClass ic, mat theta) = CartanClass:
  Cartan_class(KGB_elt(ic,theta,ratvec:null(rank(ic))))

set status (vec alpha,KGBElt x) = int: status(root_index(real_form(x),alpha),x)

set cross (vec alpha,KGBElt x) = KGBElt:
  cross(root_index(root_datum(x),alpha),x)
set Cayley (vec alpha,KGBElt x) = KGBElt:
  Cayley(root_index(real_form(x),alpha),x)

{ cross action of Weyl group element; avoid name conflict cross@(vec,KGBElt) }
set W_cross ([int] w,KGBElt x) = KGBElt:
  for i:#w downto 0 do x:=cross(w[i],x) od; x

set KGB_status_text (int i) = string: ["C-","ic","r ","nc","C+"][i]

set status_text ((int,KGBElt)p) = string: KGB_status_text(status(p))
set status_text ((vec,KGBElt)p) = string: KGB_status_text(status(p))
set status_texts (KGBElt x) = [string]:
  for s:semisimple_rank(real_form(x)) do status_text(s,x) od

set is_complex ((int,KGBElt)p) = status(p)%4=0
set is_real ((int,KGBElt)p) = status(p)=2
set is_imaginary ((int,KGBElt)p) = status(p)%2=1
set is_noncompact ((int,KGBElt)p) = status(p)=3
set is_compact ((int,KGBElt)p) = status(p)=1
set is_descent ((int,KGBElt)p) = status(p)<3
set is_ascent ((int,KGBElt)p) = status(p)>=3



{ status of general roots for a KGBElt (which here just represents its fiber) }

set is_imaginary (KGBElt x) = (vec->bool): is_imaginary(involution(x))
set is_real (KGBElt x)      = (vec->bool): is_real(involution(x))
set is_complex (KGBElt x)   = (vec->bool): is_complex(involution(x))


set imaginary_posroots (KGBElt x) = mat:
  imaginary_posroots(real_form(x),involution(x))
set real_posroots (KGBElt x) = mat:
  real_posroots(real_form(x),involution(x))
set imaginary_poscoroots (KGBElt x) = mat:
  imaginary_poscoroots(real_form(x),involution(x))
set real_poscoroots (KGBElt x) = mat:
  real_poscoroots(real_form(x),involution(x))
set imaginary_sys (KGBElt x) = (mat,mat):
  let p = (RootDatum:real_form(x),involution(x))
  in (imaginary_posroots(p),imaginary_poscoroots(p))
set real_sys (KGBElt x) = (mat,mat):
  let p = (RootDatum:real_form(x),involution(x))
  in (real_posroots(p),real_poscoroots(p))

set rho_i (KGBElt x) = ratvec: sum(imaginary_posroots(x))/2
set rho_r (KGBElt x) = ratvec: sum(real_posroots(x))/2
set rho_check_i (KGBElt x) = ratvec: sum(imaginary_poscoroots(x))/2
set rho_check_r (KGBElt x) = ratvec: sum(real_poscoroots(x))/2

{ status for a given KGBElt of general imaginary roots }
set is_compact (KGBElt x) = (vec->bool):
  let coweight = rho_check_i(x)+torus_factor(x)
  in (vec alpha) bool: =(coweight*alpha)%2
set is_noncompact (KGBElt x) = (vec->bool):
  let coweight = rho_check_i(x)+torus_factor(x)
  in (vec alpha) bool: !=(coweight*alpha)%2

set compact_posroots (KGBElt x) = mat:
  columns_with(is_compact(x),imaginary_posroots(x))
set noncompact_posroots (KGBElt x) = mat:
  columns_with(is_noncompact(x),imaginary_posroots(x))

set is_imaginary (vec v,KGBElt x) = bool: is_imaginary(x)(v)
set is_real (vec v,KGBElt x) =      bool: is_real(x)(v)
set is_complex (vec v,KGBElt x) =   bool: is_complex(x)(v)
set is_compact (vec v,KGBElt x) =   bool: is_compact(x)(v)

set print_KGB (KGBElt x) = void:
( prints(); prints("Element is number ",#x, " in following KGB set")
; print_KGB(real_form(x)) )


{				Blocks					}

set blocks (InnerClass ic) = [Block]:
  let result = [Block]: [] in
  for rf in real_forms(ic)
  do for drf in dual_real_forms(ic)
     do if is_compatible(rf,drf) then result #:= block(rf,drf) fi
     od
  od; result

set raw_KL  ((RealForm,RealForm) p) = (mat,[vec],vec): raw_KL(block(p))
set dual_KL ((RealForm,RealForm) p) = (mat,[vec],vec): dual_KL(block(p))

set print_block  ((RealForm,RealForm) p) = void: print_block (block(p))
set print_blocku ((RealForm,RealForm) p) = void: print_blocku(block(p))
set print_blockd ((RealForm,RealForm) p) = void: print_blockd(block(p))
set print_KL_basis ((RealForm,RealForm) p) = void: print_KL_basis(block(p))
set print_prim_KL  ((RealForm,RealForm) p) = void: print_prim_KL(block(p))
set print_KL_list  ((RealForm,RealForm) p) = void: print_KL_list(block(p))
set print_W_cells  ((RealForm,RealForm) p) = void: print_W_cells(block(p))
set print_W_graph  ((RealForm,RealForm) p) = void: print_W_cells(block(p))


{			    Module parameters				}

set != (Param x,Param y) = bool: not(x=y)

set root_datum (Param p) = RootDatum: real_form(p)
set inner_class (Param p) = InnerClass: real_form(p)

set null_module (Param p) = ParamPol:
  null_module(real_form(p)) { avoid using ParamPol version below, could throw }

{ deforming |nu| (operand order avoids conflicting with *@(int,ParamPol) ) }
set * (Param p,rat f) = Param: { multiplying the infinitesmal character works: }
  let (x,lambda_rho,gamma)=%p in param(x,lambda_rho,gamma*f)

set x (Param p) = KGBElt: let (x,,) =%p in x
set lambda_minus_rho (Param p) = vec: let (,lambda_rho,) =%p in lambda_rho
set lambda (Param p) = ratvec: lambda_minus_rho(p)+rho(real_form(p))
set infinitesimal_character (Param p) = ratvec: let (,,gamma) =%p in gamma
set nu (Param p) = ratvec: let (x,,gamma) =%p in (1-involution(x))*gamma/2

set involution (Param p)=involution(x(p))

set integrality_datum (Param p)= RootDatum:
  integrality_datum(root_datum(p),infinitesimal_character(p))

set is_regular (Param p) = bool:
  is_regular(root_datum(p),infinitesimal_character(p))

set trivial (RealForm G) = Param: { parameter for the trivial representation }
  param(KGB(G,KGB_size(G)-1),null(rank(G)),rho(G))

{ cross action of Weyl group element; avoid name conflict cross@(vec,Param) }
set W_cross ([int] w,Param p) = Param:
  for i:#w downto 0 do p:=cross(w[i],p) od; p

{ parameter(G,x,lambda,nu)=param(KGB(G,x),lambda-rho(G),nu), so you can enter
  lambda without the rho shift; lambda may have denominator 2 or be a vec
}
set parameter (RealForm G,int x,ratvec lambda,ratvec nu) = Param:
  param(KGB(G,x),ratvec_as_vec(lambda-rho(G)),nu)
set parameter (KGBElt x,ratvec lambda,ratvec nu) = Param:
  param(x,ratvec_as_vec(lambda-rho(real_form(x))),nu)

{ set parameter ensuring (upon sucess) that the inf. char. is gamma }
set parameter_gamma(KGBElt x, ratvec lambda, ratvec gamma) = Param:
  let (G,nx)=%x, theta=involution(x) in
  { ((1-theta)*lambda+(1+theta)*gamma)/2 = (1+theta)*(gamma-lambda)/2+lambda }
  parameter(G,nx,(1+theta)*(gamma-lambda)/2+lambda,gamma)

{ get just the parameters from a block, just a shorcut to: (params,)=block(p) }
set block_of (Param p) = [Param]: let (params,)=block(p) in params

{ status of parameter with respect to integrality generator s, or root alpha }

set imaginary_type (int s, Param p) = int: if cross(s,p)=p then 2 else 1 fi
set real_type (int s,Param p) = int: if cross(s,p)=p then 1 else 2 fi

set imaginary_type (vec alpha, Param p) = int:
  if cross(alpha,p)=p then 2 else 1 fi
set real_type (vec alpha, Param p) = int:
  if cross(alpha,p)=p then 1 else 2 fi

set is_nonparity (int s,Param p)=bool: is_real(s,x(p)) and inv_Cayley(s,p)=p
set is_parity (int s,Param p)= bool: is_real(s,x(p)) and inv_Cayley(s,p)!=p

set is_nonparity (vec alpha,Param p)=bool:
  is_real(alpha,x(p)) and Cayley(alpha,p)=p
set is_parity (vec alpha,Param p)= bool:
  is_real(alpha,x(p)) and Cayley(alpha,p)!=p

set status (vec alpha,Param p) = int: { enum: C-, ic, r1, r2, C+, rn, i1, i2 }
  let st=status(alpha,x(p)) in
  if st<=1 or st=4 then st { complex and imaginary compact cases keep old code }
  elif st=3 then { imaginary non-compact } 5+imaginary_type(alpha,p)
  elif Cayley(alpha,p)=p then { real non-parity } 5
  else 1+real_type(alpha,p)
  fi

set status (int s,Param p) = int: { this is NOT related to status(s,x(p)) }
  status(root(integrality_datum(p),s),p)

set block_status_text (int i) = string:
  case i in "C-","ic","r1","r2","C+","rn","i1","i2" esac

set status_text (int s,Param p) = string: block_status_text(status(s,p))
set status_texts (Param p) = [string]:
  for s:semisimple_rank(real_form(p)) do status_text(s,p) od

set status_text ((vec,Param) ap) = string: block_status_text(status(ap))

set parity_poscoroots (Param p) = mat: { set of positive real parity coroots }
  let (alpha,real_poscoroots)=real_sys(x(p))
  in columns_with((int i):status(alpha[i],p)!=5,real_poscoroots)
set nonparity_poscoroots (Param p) = mat: { positive real nonparity coroots }
  let (alpha,real_poscoroots)=real_sys(x(p))
  in columns_with((int i):status(alpha[i],p)=5,real_poscoroots)

set is_descent (int s,Param p) = bool: status(s,p)<4
set tau_bitset (Param p) = ((int->bool),int):
  ((int s): is_descent(s,p), semisimple_rank(real_form(p)))

set tau (Param p)            = [int]: list(tau_bitset(p))
set tau_complement (Param p) = [int]: complement(tau_bitset(p))

set is_descent ((vec,Param) ap) = bool: status(ap)<4

set lookup (Param p, [Param] block) = int:
  let i=#block-1 in while >=i and block[i]!=p do i-:=1 od; i



{		    Polynomials in module parameters			}

set null_module (ParamPol P) = ParamPol: 0*P
set first_param (ParamPol P) = Param: let (,p)=first_term(P) in p
set last_param (ParamPol P)  = Param: let (,p)=last_term(P) in p

set s_to_1 (ParamPol P)       = ParamPol: 0*P + for x@q in P do (+%x,q) od
set s_to_minus_1 (ParamPol P) = ParamPol: 0*P + for x@q in P do (-%x,q) od

{ counterpart to built-in +@(ParamPol,(Split,Param)) }
set - (ParamPol a, (Split,Param) (c,p)) = ParamPol: a+(-c,p)

{ deform a whole ParamPol, by deforming all individual terms }
set * (ParamPol P, rat f) = ParamPol: 0*P + for c@q in P do (c,q*f) od

{ simulate coercion (KGBElt->RealForm) in some cases }
set root_datum (ParamPol P) = RootDatum: real_form(P)

set virtual (Param p) = ParamPol: p { for making implicit conversion explcit }
set virtual (RealForm G, [Param] ps) = ParamPol:
  let one=Split:(1,0) in null_module(G)+for p in ps do (one,p) od
{ DON'T define virtual ([Param] pp): cannot be correctly defined when #pp=0 }

{ nice output of ParamPol: split_format the coefficients }
set pol_format (ParamPol P)= void:
  for w@p in P
  do prints("(",split_format(w),")*",p,", ",infinitesimal_character(p)) od

{ find what should be unique infintesimal character shared by all terms }
set infinitesimal_character(ParamPol P) = ratvec:
  assert(!=P,"empty polynomial has no infinitesimal character");
  let (,,gamma)=%first_param(P) in
  for @p in P
  do assert(infinitesimal_character(p)=gamma
           ,"infinitesimal character not unique")
  od; gamma

{ more generally, groups terms into different ParamPol, by value of gamma }
set separate_by_infinitesimal_character (ParamPol P) = [(ratvec,ParamPol)]:
  let M = [(ratvec,ParamPol)]:[]
  then insert ((Split,Param)(,p):term ) = void: { insert into M }
    let inserted=false, gamma=infinitesimal_character(p) in
    for (key,P)@i in M
    do if key=gamma then M[i]:=(key,P+term); inserted:=true fi
    od
  ; if not inserted then M #:= (gamma,ParamPol: p) fi
  in for c@p in P do insert(c,p) od; M

{				Miscellaneous				}

{ find index of item in list, or -1 if not found }
set find (int it,[int] list) = int:
 let i=#list-1 in while >=i and list[i]!=it do i-:=1 od; i

set in_string_list (string s,[string] S)=bool:
  let i=#S-1 in while >=i and S[i]!=s do i-:=1 od; >=i

set positive_imaginary_roots_and_coroots = imaginary_sys@(RootDatum,mat)
set positive_imaginary_roots_and_coroots = imaginary_sys@KGBElt

set imaginary_roots_and_coroots ((RootDatum, mat)p) = (mat,mat):
  let (a,b)=imaginary_sys(p) in (negative_system(a)#a,negative_system(b)#b)
set imaginary_roots_and_coroots (KGBElt x) = (mat,mat):
  imaginary_roots_and_coroots (root_datum(real_form(x)),involution(x))

set positive_real_roots_and_coroots = real_sys@(RootDatum,mat)
set positive_real_roots_and_coroots = real_sys@KGBElt

set real_roots_and_coroots ((RootDatum, mat)p) = (mat,mat):
  let (a,b)=real_sys(p) in (negative_system(a)#a,negative_system(b)#b)
set real_roots_and_coroots (KGBElt x) = (mat,mat):
  real_roots_and_coroots (root_datum(real_form(x)),involution(x))

set complex_posroots (RootDatum rd,mat theta) =  mat:
  columns_with(is_complex(theta),posroots(rd))
set complex_posroots (KGBElt x) =  mat:
  complex_posroots(root_datum(x),involution(x))

{ for user convenience; a ParamPol is an associative array ParamPol->Split
  so selecting its monomials (Param values) by position is not reliable, but
  allowing so is useful in user sessions to pick terms from a computed result
}
set monomials(ParamPol P) = [Param]: for c@p in P do p od
set monomial(ParamPol P,int i) = Param: monomials(P)[i]
